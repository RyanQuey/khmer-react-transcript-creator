{"version":3,"sources":["lib/updated-react-speech-recognition/src/index.js","lib/updated-react-speech-recognition/src/SpeechRecognition.js","lib/Util/timecode-converter/secondsToTimecode.js","lib/GenerateTranscript/helpers/book-names.js","lib/GenerateTranscript/helpers/khmer-helpers.js","lib/GenerateTranscript/helpers/combine-keywords.js","lib/GenerateTranscript/index.js","index.js","index.module.css"],"names":["SpeechRecognition","options","SpeechRecognitionInner","WrappedComponent","listening","BrowserSpeechRecognition","window","SpeechRecognitionAlternative","webkitSpeechRecognition","mozSpeechRecognition","msSpeechRecognition","oSpeechRecognition","recognition","browserSupportsSpeechRecognition","autoStart","start","pauseAfterDisconnect","interimTranscript","finalTranscript","newTranscriptData","status","wonid","punct","words","_Component","SpeechRecognitionContainer","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","minElapsed","Date","now","state","speechTimerStartedAt","newWordData","wordResults","transcript","allWordData","transcriptData","length","end","toLowerCase","replace","confidence","word","index","onRecognitionDisconnect","setState","startListening","updateTranscript","event","newState","allResults","results","console","log","i","resultIndex","isFinal","concatTranscripts","push","resetTranscript","disconnect","DOMException","abortListening","stopListening","inherits","createClass","key","value","continuous","interimResults","onresult","bind","onend","disconnectType","abort","stop","_len","arguments","transcriptParts","Array","_key","map","t","trim","join","totalTimeElapsed","react_default","a","createElement","assign","Component","secondsToTimecode","seconds","framePerSeconds","fps","undefined","normalisedSeconds","Number","Math","floor","toPrecision","toFixed","normalisePlayerTime","wholeSeconds","frames","_padZero","n","concat","parseInt","BOOKS_STR","BOOKS_ARR","_nums","BOOKS_WITH_MANY","filter","b","includes","BOOKS_WITH_MANY_NO_NUM","_","uniq","substring","ALL_BOOKS_NO_NUM","bookNames","KHMER_NUMBERS","KHMER_NUMERALS","KHMER_PUNCTUATION_NO_LEADER","ល៉ៈ ","KHMER_PUNCTUATION_NO_LEADER_KEYS","keys","KHMER_PUNCTUATION","ខណ្ឌ","ខ័ណ្ឌ","។","សួរ","ឧទាន","MULTI_WORD_KHMER_PUNCTUATION","(",")","៖","«","»","KHMER_PUNCTUATION_KEYS","ALL_KHMER_PUNCTUATION","bonusOrdinals","khOrdinalIndicatorArr","isNumber","str","match","khmer_helpers","khPart","khOrdinalIndicatorRegEx","RegExp","khOrdinalRegEx","khNumber","khChapter","khChapterRegex","khVerse","khVerseRegex","referencesRegex","khmerNumberRegex","nonGlobalRegex","reg","source","convertToKhmerNumeral","numStr","ret","spelledOutIndex","indexOf","punctuationRegex","preferredSpellingRegex","PREFERRED_SPELLINGS","khPunctuationLeader","isEnglish","wordData","ZERO_WIDTH_SPACE","isOrdinal","word1","word2","wordIsFollowedBySpace","nextWordData","tags","multiwordPunctuationMatch","allWords","currentIndex","some","valArr","every","wordToMatch","matchedWordsData","range","punctuation","multiwordLength","originalWordData","averageConfidence","reduce","acc","val","endTime","last","secondWordData","thirdWordData","fourthWordData","PUNCTUATION_EXTRA_TAGS","?","!","manualFixes","modified","target","GenerateTranscript","editorState","EditorState","createEmpty","error","moveFocusToEnd","oldWords","oldEditorState","replacer","shouldAddSpace","onChange","pause","assertThisInitialized","reset","copy","undo","lang","e","text","getCurrentContent","getPlainText","input","document","setAttribute","body","appendChild","select","result","execCommand","removeChild","objectSpread","_this2","_this$props","defaultValue","data-placeholder","disabled","onClick","onMouseDown","preventDefault","name","type","checked","className","style","color","Draft","width","placeholder","newReplacer","JSON","parse","sentence","phrase","textToAdd","forEach","modifier","startTime","isDefault","Helpers","num","numberMatch","number","nonNumbers","preferredSpelling","processedWordData","combineKeywords","split","currentContent","selection","getSelection","textWithInsert","Modifier","insertText","newEditorState","toConsumableArray","App","handleIsTextEditable","prevState","isTextEditable","handleSttTypeChange","defineProperty","handleExportFormatChange","exportTranscript","_this$transcriptEdito","transcriptEditorRef","current","getEditorContent","exportFormat","data","ext","download","mediaUrl","content","filename","contentType","blob","Blob","href","URL","createObjectURL","click","clearLocalStorage","localStorage","clear","info","handleAnalyticsEvents","analyticsEvents","handleChangeTranscriptName","fileName","sttType","playingWhileListening","React","createRef","startListeningAndPlayingMedia","khmerRougeTranscript","files","file","canPlayType","fileURL","alert","prompt","fr","FileReader","onload","evt","readAsText","container","title","rel","lib_GenerateTranscript","render","src_App","getElementById","module","exports"],"mappings":"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","file":"static/js/main.3951fb55.chunk.js","sourcesContent":["import SpeechRecognition from './SpeechRecognition'\n\nexport default SpeechRecognition\n","import React, { Component } from 'react'\n\nexport default function SpeechRecognition(options) {\n  const SpeechRecognitionInner = function (WrappedComponent) {\n    const BrowserSpeechRecognition =\n      typeof window !== 'undefined' &&\n      (window.SpeechRecognitionAlternative ||\n        window.webkitSpeechRecognition ||\n        window.mozSpeechRecognition ||\n        window.msSpeechRecognition ||\n        window.oSpeechRecognition)\n    const recognition = BrowserSpeechRecognition\n      ? new BrowserSpeechRecognition()\n      : null\n    const browserSupportsSpeechRecognition = recognition !== null\n    let listening\n    if (\n      !browserSupportsSpeechRecognition ||\n      (options && options.autoStart === false)\n    ) {\n      listening = false\n    } else {\n      recognition.start()\n      listening = true\n    }\n    let pauseAfterDisconnect = false\n    let interimTranscript = ''\n    let finalTranscript = ''\n\n    // TODO put this as the retval key using template found in src/sample-data/KateDarling_2018S-bbc-kaldi.json\n    const newTranscriptData = () => ({\n      status: true,\n      wonid: \"octo:2692ea33-d595-41d8-bfd5-aa7f2d2f89ee\", // don't know this one, probably will generate something\n      punct: \"\", // total transcript of all the words TODO currently not setting\n      words: [], // array of newWordData objects\n    })\n    \n\n    return class SpeechRecognitionContainer extends Component {\n      constructor(props) {\n        super(props)\n\n        this.state = {\n          interimTranscript,\n          finalTranscript,\n          transcriptData: {},\n          listening: false,\n          allResults: [],\n          speechTimerStartedAt: false, // ms since Jan 1 1970\n        }\n\n        // TODO do the binding thing so don't have to do the crazy arrow funcs here\n      }\n\n      componentWillMount() {\n        if (recognition) {\n          recognition.continuous = false // originally set to true, but this breaks up the words into smaller fragments much better\n          recognition.interimResults = true\n          recognition.onresult = this.updateTranscript.bind(this)\n          recognition.onend = this.onRecognitionDisconnect.bind(this)\n          // onspeechstart/end or onsoundstart/end might be useful\n          /*\n    recognition.onspeechend = () => {console.log(\"speech is now ending\")}\n    recognition.onspeechstart = () => {console.log(\"speech is now starting\")}\n    recognition.onsoundstart = () => {console.log(\"sound is now starting\")}\n    recognition.onsoundend = () => {console.log(\"sound is now ending\")}\n    recognition.nomatch = () => {console.log(\"no match!!!11\")}\n    recognition.onboundary = () => {console.log(\"boundary found!\")}\n    recognition.onresume = () => {console.log(\"resume found!\")}\n    recognition.onmark = () => {console.log(\"mark found!\")}\n    recognition.onpause = () => {console.log(\"pause found!\")}\n    */\n          this.setState({\n            listening,\n            transcriptData: newTranscriptData()\n          })\n        }\n      }\n\n      disconnect (disconnectType) {\n        if (recognition) {\n          switch (disconnectType) {\n            case 'ABORT':\n              pauseAfterDisconnect = true\n              recognition.abort()\n              break\n            case 'RESET':\n              pauseAfterDisconnect = true\n              recognition.abort()\n              break\n            case 'STOP':\n            default:\n              pauseAfterDisconnect = true\n              recognition.stop()\n          }\n        }\n      }\n\n      // minutes elapsed since started.\n      minElapsed = () => {\n        return (Date.now() - this.state.speechTimerStartedAt)/1000;\n      }\n\n      newWordData = (wordResults) => {\n        const words = wordResults.transcript;\n        // remove all punctuation and lowercase it\n        const allWordData = this.state.transcriptData.words;\n        const start = allWordData.length > 0 ? allWordData[allWordData.length - 1].end : 0;\n        const end = this.minElapsed();\n        const punct = words.toLowerCase().replace(/[.,\\/#!$%\\^&\\*;:{}=\\-_`~()]/g, '');\n\n        // format required for the bbc lib\n        return {\n          start, // time in minutes, using decimals not seconds, eg 13.02 (float)\n          confidence: wordResults.confidence, // %, out of 1, eg 0.68 (float)\n          end, // end time in min\n          word: words, // all words, not formatted (and lowercase), eg \"there\" (string)\n          punct, // word, as displayed, eg \"There\" (string)\n          index: allWordData.length,\n        }\n      }\n\n      onRecognitionDisconnect = () => {\n        listening = false\n        if (pauseAfterDisconnect) {\n          this.setState({ listening })\n        } else {\n          this.startListening()\n        }\n        pauseAfterDisconnect = false\n      }\n\n      // TODO might stop getting interim results and handling them if it hurts performance\n      updateTranscript = (event) => {\n        interimTranscript = ''\n        // looks like they iterate over same results every time, rather than gradually compiling as it goes. Could slow things down if transcript gets long TODO\n        let newState = {\n          // might not need\n          allResults: event.results\n        }\n        console.log(event);\n        for (let i = event.resultIndex; i < event.results.length; ++i) {\n          if (event.results[i].isFinal) {\n            let wordResults = event.results[i][0]\n            finalTranscript = this.concatTranscripts(\n              finalTranscript,\n              wordResults.transcript\n            )\n\n            let newWordData = this.newWordData(wordResults)\n            //TODO bad practice modifying original object like this!\n            let transcriptData = this.state.transcriptData\n            transcriptData.words.push(newWordData)\n            \n            newState.finalTranscript = finalTranscript\n            newState.transcriptData = transcriptData\n\n          } else {\n            interimTranscript = this.concatTranscripts(\n              interimTranscript,\n              event.results[i][0].transcript\n            )\n            newState.interimTranscript = interimTranscript\n          }\n        }\n\n        this.setState(newState)\n      }\n\n      // returns string with all transcript together\n      concatTranscripts(...transcriptParts) {\n        return transcriptParts.map(t => t.trim()).join(' ').trim()\n      }\n\n      resetTranscript = () => {\n        interimTranscript = ''\n        finalTranscript = ''\n        this.disconnect('RESET')\n        this.setState({ \n          interimTranscript, \n          finalTranscript,\n          transcriptData: newTranscriptData(),\n          speechTimerStartedAt: false,\n        })\n      }\n\n      startListening = () => {\n        if (recognition && !listening) {\n          try {\n            recognition.start()\n          } catch (DOMException) {\n            // Tried to start recognition after it has already started - safe to swallow this error\n          }\n          listening = true\n          let newState = {listening}\n          if (!this.state.speechTimerStartedAt) {\n            newState.speechTimerStartedAt = Date.now()\n          }\n\n          this.setState(newState)\n        }\n      }\n\n      abortListening = () => {\n        listening = false\n        this.setState({ listening })\n        this.disconnect('ABORT')\n      }\n\n      stopListening = () => {\n        listening = false\n        this.setState({ listening })\n        this.disconnect('STOP')\n      }\n\n      render() {\n        // includes both\n        const transcript = this.concatTranscripts(\n          finalTranscript,\n          interimTranscript\n        )\n\n        const totalTimeElapsed = this.minElapsed()\n\n        return (\n          <WrappedComponent\n            resetTranscript={this.resetTranscript}\n            startListening={this.startListening}\n            abortListening={this.abortListening}\n            stopListening={this.stopListening}\n            transcript={transcript}\n            recognition={recognition}\n            allResults={this.state.allResults}\n            listening={this.state.listening}\n            transcriptData={this.state.transcriptData}\n            interimTranscript={this.state.interimTranscript}\n            finalTranscript={this.state.finalTranscript}\n            browserSupportsSpeechRecognition={browserSupportsSpeechRecognition}\n            totalTimeElapsed={totalTimeElapsed}\n            {...this.props} />\n        )\n      }\n    }\n  }\n\n  if (typeof options === 'function') {\n    return SpeechRecognitionInner(options)\n  } else {\n    return SpeechRecognitionInner\n  }\n}\n","/**\n* Raised in this comment https://github.com/bbc/react-transcript-editor/pull/9\n* abstracted from https://github.com/bbc/newslabs-cdn/blob/master/js/20-bbcnpf.utils.js\n* In broadcast VIDEO, timecode is NOT hh:mm:ss:ms, it's hh:mm:ss:ff where ff is frames,\n* dependent on the framerate of the media concerned.\n* `hh:mm:ss:ff`\n*/\n\n/**\n * Helper function\n * Rounds to the 14milliseconds boundaries\n * Time in video can only \"exist in\" 14milliseconds boundaries.\n * This makes it possible for the HTML5 player to be frame accurate.\n * @param {*} seconds\n * @param {*} fps\n */\nconst normalisePlayerTime = function (seconds, fps) {\n  return Number((1.0 / fps * Math.floor(Number((fps * seconds).toPrecision(12)))).toFixed(2));\n};\n\n/*\n* @param {*} seconds\n* @param {*} fps\n*/\nconst secondsToTimecode = function (seconds, framePerSeconds) {\n  // written for PAL non-drop timecode\n  let fps = 25;\n  if (framePerSeconds !== undefined) {\n    fps = framePerSeconds;\n  }\n\n  const normalisedSeconds = normalisePlayerTime(seconds, fps);\n\n  const wholeSeconds = Math.floor(normalisedSeconds);\n  const frames = ((normalisedSeconds - wholeSeconds) * fps).toFixed(2);\n\n  // prepends zero - example pads 3 to 03\n  function _padZero(n) {\n    if (n < 10) return `0${ parseInt(n) }`;\n\n    return parseInt(n);\n  }\n\n  return `${ _padZero((wholeSeconds / 60 / 60) % 60)\n  }:${\n    _padZero((wholeSeconds / 60) % 60)\n  }:${\n    _padZero(wholeSeconds % 60)\n  }:${\n    _padZero(frames) }`;\n};\n\nexport default secondsToTimecode;\n","import _ from \"lodash\";\n\nexport const BOOKS_STR =\n  \"លោកុប្បត្តិ,និក្ខមនំ,លេវីវិន័យ,ជនគណនា,ទុតិយកថា,យ៉ូស្វេ,ចៅហ្វាយ,នាង​រស់,១ សាំយូអែល,២ សាំយូអែល,១ ពង្សាវតារក្សត្រ,២ ពង្សាវតារក្សត្រ,១ របាក្សត្រ,២ របាក្សត្រ,អែសរ៉ា,នេហេមា,នាង​អេសធើរ,យ៉ូប,ទំនុកតម្កើង,សុភាសិត,សាស្ដា,បទ​ចំរៀង,អេសាយ,យេរេមា,បរិទេវ,អេសេគាល,ដានីយ៉ែល,ហូសេ,យ៉ូអែល,អេម៉ុស,អូបាឌា,យ៉ូណាស,មីកា,ណាហ៊ូម,ហាបាគូក,សេផានា,ហាកាយ,សាការី,ម៉ាឡាគី,ម៉ាថាយ,ម៉ាកុស,លូកា,យ៉ូហាន,កិច្ចការ,រ៉ូម,១ កូរិនថូស,២ កូរិនថូស,កាឡាទី,អេភេសូ,ភីលីព,កូឡូស,១ ថេស្សាឡូនិក,២ ថេស្សាឡូនិក,១ ធីម៉ូថេ,២ ធីម៉ូថេ,ទីតុស,ភីលេម៉ូន,ហេប្រឺ,យ៉ាកុប,១ ពេត្រុស,២ ពេត្រុស,១ យ៉ូហាន,២ យ៉ូហាន,៣ យ៉ូហាន,យូដាស,វិវរណៈ\";\nexport const BOOKS_ARR = [\n  \"លោកុប្បត្តិ\",\n  \"និក្ខមនំ\",\n  \"លេវីវិន័យ\",\n  \"ជនគណនា\",\n  \"ទុតិយកថា\",\n  \"យ៉ូស្វេ\",\n  \"ចៅហ្វាយ\",\n  \"នាង​រស់\",\n  \"១ សាំយូអែល\",\n  \"២ សាំយូអែល\",\n  \"១ ពង្សាវតារក្សត្រ\",\n  \"២ ពង្សាវតារក្សត្រ\",\n  \"១ របាក្សត្រ\",\n  \"២ របាក្សត្រ\",\n  \"អែសរ៉ា\",\n  \"នេហេមា\",\n  \"នាង​អេសធើរ\",\n  \"យ៉ូប\",\n  \"ទំនុកតម្កើង\",\n  \"សុភាសិត\",\n  \"សាស្ដា\",\n  \"បទ​ចំរៀង\",\n  \"អេសាយ\",\n  \"យេរេមា\",\n  \"បរិទេវ\",\n  \"អេសេគាល\",\n  \"ដានីយ៉ែល\",\n  \"ហូសេ\",\n  \"យ៉ូអែល\",\n  \"អេម៉ុស\",\n  \"អូបាឌា\",\n  \"យ៉ូណាស\",\n  \"មីកា\",\n  \"ណាហ៊ូម\",\n  \"ហាបាគូក\",\n  \"សេផានា\",\n  \"ហាកាយ\",\n  \"សាការី\",\n  \"ម៉ាឡាគី\",\n  \"ម៉ាថាយ\",\n  \"ម៉ាកុស\",\n  \"លូកា\",\n  \"យ៉ូហាន\",\n  \"កិច្ចការ\",\n  \"រ៉ូម\",\n  \"១ កូរិនថូស\",\n  \"២ កូរិនថូស\",\n  \"កាឡាទី\",\n  \"អេភេសូ\",\n  \"ភីលីព\",\n  \"កូឡូស\",\n  \"១ ថេស្សាឡូនិក\",\n  \"២ ថេស្សាឡូនិក\",\n  \"១ ធីម៉ូថេ\",\n  \"២ ធីម៉ូថេ\",\n  \"ទីតុស\",\n  \"ភីលេម៉ូន\",\n  \"ហេប្រឺ\",\n  \"យ៉ាកុប\",\n  \"១ ពេត្រុស\",\n  \"២ ពេត្រុស\",\n  \"១ យ៉ូហាន\",\n  \"២ យ៉ូហាន\",\n  \"៣ យ៉ូហាន\",\n  \"យូដាស\",\n  \"វិវរណៈ\",\n].concat([\n  // add some alt spellings that Google might send\n  \"១ ពង្សាវតាក្សត្រ\",\n  \"២ ពង្សាវតាក្សត្រ\",\n]);\n\nconst _nums = [\"១\", \"២\", \"៣\"];\n// TODO for performance don't run all this stuff on initialization, do it when it's called or\n// something\n// all the books that have more than one\nexport const BOOKS_WITH_MANY = BOOKS_ARR.filter((b) => _nums.includes(b[0]));\n// take away the number for them\nexport const BOOKS_WITH_MANY_NO_NUM = _.uniq(\n  BOOKS_WITH_MANY.map((b) => b.substring(2))\n);\nexport const ALL_BOOKS_NO_NUM = _.uniq(\n  BOOKS_ARR.map((b) => {\n    if (BOOKS_WITH_MANY.includes(b)) {\n      return b.substring(2);\n    } else {\n      return b;\n    }\n  })\n);\n","import PREFERRED_SPELLINGS from \"./preferred-spellings.json\";\nimport * as bookNames from \"./book-names\";\nimport _ from \"lodash\";\n\nconsole.log(bookNames);\n\n// make sure numbers correspond to index in array\nconst KHMER_NUMBERS = [\n  // numbers\n  \"សូន្យ\",\n  \"មួយ\",\n  \"ពីរ\",\n  \"បី\",\n  \"បួន\",\n  \"ប្រាំ\",\n  \"ប្រាំមួយ\",\n  \"ប្រាំពីរ\",\n  \"ប្រាំបី\",\n  \"ប្រាំបួន\",\n];\nconst KHMER_NUMERALS = [\n  // numbers\n  \"០\",\n  \"១\",\n  \"២\",\n  \"៣\",\n  \"៤\",\n  \"៥\",\n  \"៦\",\n  \"៧\",\n  \"៨\",\n  \"៩\",\n];\n\n// none of these will require \"sanna\" (kh for \"sign\") before recognizing it\nconst KHMER_PUNCTUATION_NO_LEADER = {\n  \"ល៉ៈ \": \"។ល។\",\n};\n// for performance want to only run once, not for every word in every transcript!\nconst KHMER_PUNCTUATION_NO_LEADER_KEYS = Object.keys(\n  KHMER_PUNCTUATION_NO_LEADER\n);\n\n// all of these will require \"sanna\" (kh for \"sign\") before recognizing it\nconst KHMER_PUNCTUATION = {\n  ខណ្ឌ: \"។ \",\n  ខ័ណ្ឌ: \"។ \",\n  // need this one too since sometimes they actually return this correctly, but we're having users\n  // say khPunctuationLeader bfeore it anyways...\n  \"។\": \"។ \",\n  សួរ: \"? \",\n  ឧទាន: \"! \",\n};\n// These are different. Keys will be what we want, values a list of the words.\n// Makes it easy to iterate over and check for matches\n// TODO for performance, don't iterate over same word \"bauk\" or \"bit\" every time!\nconst MULTI_WORD_KHMER_PUNCTUATION = {\n  // TODO test. Maybe google separates words differently for example\n  \"(\": [[\"បើក\", \"វង់\", \"ក្រចក\"]],\n  // TODO test. Maybe google separates words differently for example\n  \")\": [[\"បិត\", \"វង់\", \"ក្រចក\"]],\n  \"៖\": [[\"ចំណុច\", \"ពីរ\", \"គូស\"]],\n  \"«\": [\n    [\"បើក\", \"សញ្ញា\", \"អញ្ញ\", \"ប្រកាស\"],\n    // Google has read it this way before, so being flexible\n    [\"បើក\", \"សញ្ញា\", \"អាច\", \"ប្រកាស\"],\n    [\"សញ្ញា\", \"បើក\", \"អាច\", \"ប្រកាស\"],\n    [\"សញ្ញា\", \"បើក\", \"ៗ\", \"ប្រកាស\"],\n    [\"បើក\", \"សញ្ញា\", \"អញ្ញ\"],\n    // Google has read it this way before, so being flexible\n    [\"បើក\", \"សញ្ញា\", \"ៗ\"],\n    [\"សញ្ញា\", \"អញ្ញ\", \"បើក\"],\n    // Google has read it this way before, so being flexible\n    [\"សញ្ញា\", \"ៗ\", \"បើក\"],\n  ],\n  \"»\": [\n    // Google has read it this way before, so being flexible\n    [\"បិទ\", \"សញ្ញា\", \"អអាច\", \"ប្រកាស\"],\n    [\"បិទ\", \"សញ្ញា\", \"អញ្ញ\", \"ប្រកាស\"],\n    [\"សញ្ញា\", \"បិទ\", \"អញ្ញ\", \"ប្រកាស\"],\n    [\"សញ្ញា\", \"បិទ\", \"ៗ\", \"ប្រកាស\"],\n    [\"បិទ\", \"សញ្ញា\", \"អញ្ញ\"],\n    // Google has read it this way before, so being flexible\n    [\"បិទ\", \"សញ្ញា\", \"ៗ\"],\n    [\"សញ្ញា\", \"អញ្ញ\", \"បិទ\"],\n    // Google has read it this way before, so being flexible\n    [\"សញ្ញា\", \"ៗ\", \"បិទ\"],\n  ],\n};\n\nconst KHMER_PUNCTUATION_KEYS = Object.keys(KHMER_PUNCTUATION);\nconst ALL_KHMER_PUNCTUATION = Object.assign(\n  KHMER_PUNCTUATION,\n  KHMER_PUNCTUATION_NO_LEADER\n);\n\nconst khPunctuationLeader = \"សញ្ញា\";\n// hits anything with the khmer word for \"number\" before and then an Arabic numeral\nconst khNumber = \"លេខ\";\n// keep khmer writing on separate line if possible, or else vim gets messed up\n\n// if Google slams this together. Means \"one duck\" or \"two ducks\" but if in right context, we can\n// assume a Bible verse\nconst bonusOrdinals = [\"ទាមួយ\", \"ទាពីរ\"];\nconst khOrdinalIndicatorArr = [\n  \"ទី\",\n  // because sometimes Google sees this here instead\n  \"ទា\",\n  \"ទៀត\",\n].concat(bonusOrdinals);\nconst isNumber = (str) => str.match(/\\d/) || KHMER_NUMBERS.includes(str);\nconst ALL_BOOKS_NO_NUM = bookNames.ALL_BOOKS_NO_NUM;\n\nexport default {\n  // for different parts of a book, e.g., 1 Kings\n  khPart: \"ខ្សែ\",\n  khOrdinalIndicatorArr,\n  khOrdinalIndicatorRegEx: new RegExp(`${khOrdinalIndicatorArr.join(\"|\")}`),\n  khOrdinalRegEx: new RegExp(\n    `(${khOrdinalIndicatorArr.join(\"|\")})(\\d|${KHMER_NUMBERS.join(\"|\")})`\n  ),\n  khNumber,\n  khChapter: \"ជំពូក\",\n  // including some misspellings\n  khChapterRegex: new RegExp(\"ជំពូក|ចំពោះ|ជំពោះ\"),\n  khVerse: \"ខ\",\n  // including some misspellings\n  khVerseRegex: new RegExp(\"ខ|ខល\"),\n  referencesRegex: /\\s?ជំពូក\\s?(\\d+)\\s?ខ\\s?(\\d+)/gi,\n  // if colon before or after, counting it as reference, so handling differently\n  khmerNumberRegex: new RegExp(`(${khNumber})?\\\\s?(\\\\d)`, \"gi\"),\n  // global regexs don't capture\n  nonGlobalRegex: (reg) => new RegExp(reg.source, \"i\"),\n  // TODO I'm sure there's a more performant way to do this, but unless it's a math transcript we\n  // shouldn't call this too often anyways\n  isNumber,\n  convertToKhmerNumeral: (numStr) => {\n    const spelledOutIndex = KHMER_NUMBERS.indexOf(numStr);\n    let ret;\n    if (spelledOutIndex != -1) {\n      ret = KHMER_NUMERALS[spelledOutIndex];\n    } else {\n      ret = \"\";\n      // make sure if multidigit string, converts all\n      for (let i = 0; i < numStr.length; i++) {\n        ret += KHMER_NUMERALS[numStr[i]];\n      }\n    }\n\n    return ret;\n  },\n  punctuationRegex: new RegExp(\n    Object.keys(ALL_KHMER_PUNCTUATION).join(\"|\"),\n    \"gi\"\n  ),\n  // NOTE don't use when looking at individual words\n  preferredSpellingRegex: new RegExp(\n    Object.keys(PREFERRED_SPELLINGS).join(\"|\"),\n    \"gi\"\n  ),\n\n  khPunctuationLeader,\n  isEnglish: (wordData) => wordData.word.match(/^[a-zA-Z]+$/),\n\n  KHMER_PUNCTUATION,\n  KHMER_PUNCTUATION_NO_LEADER,\n  KHMER_PUNCTUATION_KEYS,\n  KHMER_PUNCTUATION_NO_LEADER_KEYS,\n  KHMER_NUMERALS,\n  KHMER_NUMBERS,\n  PREFERRED_SPELLINGS,\n  ZERO_WIDTH_SPACE: \"\\u200B\",\n  ALL_BOOKS_NO_NUM,\n  BOOKS_WITH_MANY_NO_NUM: bookNames.BOOKS_WITH_MANY_NO_NUM,\n  bonusOrdinals,\n  // check if set of two words returns an ordinal\n  isOrdinal: (word1, word2) =>\n    (khOrdinalIndicatorArr.includes(word1) &&\n      (KHMER_NUMBERS.includes(word2) || isNumber(word2))) ||\n    // hacky, but necessary to get edge cases\n    bonusOrdinals.includes(word1),\n\n  /*\n   * - takes a single word, which is from the utterance.alternatives[0].words array, and is tagged\n   * - since punctuation is dependent upon whether or not there is a following word and what it's\n   *   like, we need that info too\n   * @return boolean, whether or not there should be a real space (ie NOT zero-width space)\n   */\n\n  wordIsFollowedBySpace(wordData, nextWordData) {\n    const isFollowedBySpace =\n      nextWordData &&\n      ((!nextWordData.tags.includes(\"end-of-sentence\") &&\n        !nextWordData.tags.includes(\"closing-punctuation\") &&\n        wordData.tags.includes(\"followed-by-nbsp\")) ||\n        nextWordData.tags.includes(\"preceded-by-nbsp\"));\n\n    return isFollowedBySpace;\n  },\n\n  /*\n   * find sentences that are for punctuation, but are multiple words, e.g., for parenthesse and quotes.\n   */\n  multiwordPunctuationMatch: (allWords, currentIndex) => {\n    let keys = Object.keys(MULTI_WORD_KHMER_PUNCTUATION);\n    // iterate over each punctuation to see if there's a match\n    let ret = false;\n    // using some so stops when return true\n    keys.some((key) => {\n      // each punctuation might have multiple possible matches. Iterate over each one\n      let possibilitySet = MULTI_WORD_KHMER_PUNCTUATION[key];\n      // using some so stops when return true\n      // returning this, so stops enclosing some call also if this returns true\n      return possibilitySet.some((valArr) => {\n        // iterate over each word in the multi-word command to see if all match\n        // allWords[currentIndex] is the current word. i starts at 0, and sees if each word matches in\n        // succession\n        let match = valArr.every((wordToMatch, i) => {\n          return (\n            allWords[currentIndex + i] &&\n            wordToMatch == allWords[currentIndex + i].word\n          );\n        });\n        if (match) {\n          let wordData = allWords[currentIndex];\n          let matchedWordsData = _.range(valArr.length).map(\n            (i) => allWords[currentIndex + i]\n          );\n\n          ret = {\n            punctuation: key, // in this case, we're using the punctuation mark we want to return as key\n            multiwordLength: matchedWordsData.length,\n            originalWordData: { wordData },\n            averageConfidence:\n              matchedWordsData.reduce((acc, val) => acc + val.confidence, 0) /\n              matchedWordsData.length,\n            endTime: _.last(matchedWordsData).endTime,\n          };\n\n          // TODO for these use cases, rename key from secondWordData to \"wordData2\" so can easily\n          // set using originalWordData[`wordData${i}`]\n          if (valArr.length > 1) {\n            ret.originalWordData.secondWordData = matchedWordsData[1];\n          }\n          if (valArr.length > 2) {\n            ret.originalWordData.thirdWordData = matchedWordsData[2];\n          }\n          if (valArr.length > 3) {\n            ret.originalWordData.fourthWordData = matchedWordsData[3];\n          }\n          // shouldn't be more than 4, but to be safe\n          if (valArr.length > 4) {\n            ret.originalWordData.fourthWordData = matchedWordsData[4];\n          }\n\n          return true;\n        }\n      });\n    });\n\n    return ret;\n  },\n};\n","import Helpers from \"./khmer-helpers\";\n\n// extra tags to add for punctuations\nconst PUNCTUATION_EXTRA_TAGS = {\n    \"(\": [\"preceded-by-nbsp\", \"parentheses\", \"opening-punctuation\"],\n    // TODO test. Maybe google separates words differently for example\n    \")\": [\"followed-by-nbsp\", \"parentheses\", \"closing-punctuation\"],\n    \"៖\": [\"followed-by-nbsp\"],\n    \"«\": [\"preceded-by-nbsp\", \"quotation-marks\", \"opening-punctuation\"],\n    \"»\": [\"followed-by-nbsp\", \"quotation-marks\", \"closing-punctuation\"],\n    \"។\": [\"followed-by-nbsp\", \"end-of-sentence\"],\n    \"?\": [\"followed-by-nbsp\", \"end-of-sentence\"],\n    \"!\": [\"followed-by-nbsp\", \"end-of-sentence\"],\n  };\n  \nexport function combineKeywords(words) {\n  const ret = [];\n  for (let i = 0; i < words.length; i++) {\n    let wordData = words[i];\n    let secondWordData = words[i + 1] || {};\n    // set some defaults. Will change many of them\n    let word = wordData.word,\n      originalWordData = wordData,\n      confidence = wordData.confidence,\n      endTime = wordData.endTime,\n      startTime = wordData.startTime,\n      tags = [],\n      isDefault = true;\n\n    if (Helpers.ALL_BOOKS_NO_NUM.includes(wordData.word)) {\n      let thirdWordData = words[i + 2] || {};\n      let fourthWordData = words[i + 3] || {};\n      console.log(\"got a book!\", [\n        wordData.word,\n        secondWordData.word,\n        thirdWordData.word,\n        fourthWordData.word,\n      ]);\n      // is book of Bible, so watch out for funky handling by Google\n      // But not necessarily non-default\n\n      if (\n        Helpers.BOOKS_WITH_MANY_NO_NUM.includes(wordData.word) &&\n        Helpers.khPart == secondWordData.word &&\n        Helpers.isOrdinal(thirdWordData.word, fourthWordData.word)\n      ) {\n        isDefault = false;\n        // if 3rd is an ordinal by itself, it means Google sent the ordinal bunched together as\n        // one \"word\", so the fourth is not included\n        let allInOne = Helpers.bonusOrdinals.includes(thirdWordData.word);\n        if (allInOne) {\n          let num = thirdWordData.word.replace(\n            Helpers.khOrdinalIndicatorRegEx,\n            \"\"\n          );\n          word = `${Helpers.convertToKhmerNumeral(num)}${wordData.word}`;\n          confidence =\n            [wordData, secondWordData, thirdWordData].reduce(\n              (acc, val) => acc + val.confidence,\n              0\n            ) / 3;\n          originalWordData = { wordData, secondWordData, thirdWordData };\n          // leave the 4th one out of it\n          i += 2;\n        } else {\n          word = `${Helpers.convertToKhmerNumeral(fourthWordData.word)}${\n            wordData.word\n          }`;\n\n          // get the average and use as combined word confidence\n          // NOTE maybe we should be even more confident, since it fits this pattern?\n          confidence =\n            [wordData, secondWordData, thirdWordData, fourthWordData].reduce(\n              (acc, val) => acc + val.confidence,\n              0\n            ) / 4;\n          originalWordData = {\n            wordData,\n            secondWordData,\n            thirdWordData,\n            fourthWordData,\n          };\n          // skip next three words since we're combining them\n          i += 3;\n        }\n\n        tags.push(\"combined\");\n        tags.push(\"preceded-by-nbsp\");\n        tags.push(\"followed-by-nbsp\");\n        tags.push(\"book-name\");\n      }\n    } else if (wordData.word.match(Helpers.khChapterRegex)) {\n      // test if this is reference\n      // NOTE that we want to do this even if no book name is recognized, since often no book is\n      // recognized at all even if the end user said one\n      let thirdWordData = words[i + 2] || {};\n      let fourthWordData = words[i + 3] || {};\n\n      if (\n        Helpers.isNumber(secondWordData.word) &&\n        thirdWordData.word &&\n        thirdWordData.word.match(Helpers.khVerse) &&\n        Helpers.isNumber(fourthWordData.word)\n      ) {\n        // found a reference\n        isDefault = false;\n        word = `${Helpers.convertToKhmerNumeral(\n          secondWordData.word\n        )}:${Helpers.convertToKhmerNumeral(fourthWordData.word)}`;\n\n        // get the average and use as combined word confidence\n        // NOTE maybe we should be even more confident, since it fits this pattern?\n        confidence =\n          [wordData, secondWordData, thirdWordData, fourthWordData].reduce(\n            (acc, val) => acc + val.confidence,\n            0\n          ) / 4;\n        endTime = fourthWordData.endTime;\n        originalWordData = {\n          wordData,\n          secondWordData,\n          thirdWordData,\n          fourthWordData,\n        };\n        tags.push(\"combined\");\n        tags.push(\"preceded-by-nbsp\");\n        tags.push(\"followed-by-nbsp\");\n        tags.push(\"reference\");\n\n        // skip next three words since we're combining them\n        i += 3;\n      }\n    } else if (\n      wordData.word == Helpers.khPunctuationLeader &&\n      Helpers.KHMER_PUNCTUATION_KEYS.includes(secondWordData.word)\n    ) {\n      // don't just test all words and their following words, will slow things down\n\n      // this is punctuation\n      isDefault = false;\n      word = Helpers.KHMER_PUNCTUATION[secondWordData.word];\n      endTime = secondWordData.endTime;\n      originalWordData = { wordData, secondWordData };\n      confidence =\n        [wordData, secondWordData].reduce(\n          (acc, val) => acc + val.confidence,\n          0\n        ) / 2;\n      tags.push(\"combined\");\n      tags.push(\"punctuation\");\n\n      // skip next word since we're combining them\n      i += 1;\n    } else if (Helpers.KHMER_PUNCTUATION_KEYS.includes(wordData.word)) {\n      // this is for when GOogle just returns the punctuation sign on their own. We did not say the khPunctuationLeader, but they returned it.\n      // Mostly only happens with ។, I think\n      // this is punctuation\n\n      isDefault = false;\n      tags.push(\"punctuation\");\n      tags.push(\"google-returned-as-punctuation\");\n    } else if (\n      Helpers.KHMER_PUNCTUATION_NO_LEADER_KEYS.includes(wordData.word)\n    ) {\n      // is no leader punctuation. Not combining\n      isDefault = false;\n      // 6/23/21 I don't know if we've tried this one before yet, but I believe the following line of code is wrong, we're not combining, we're not even looking at the second word.\n      //word = Helpers.KHMER_PUNCTUATION_NO_LEADER[secondWordData.word]\n      tags.push(\"punctuation\");\n    } else if (\n      wordData.word == Helpers.khNumber &&\n      secondWordData &&\n      Helpers.isNumber(secondWordData.word)\n    ) {\n      // TODO Handle for edge cases. Most of the time, Google returns even multidigit numbers as a\n      // single \"word\". But this is worth testing more.\n\n      // recognizing this as numeral this whether the 2nd word is spelled out Khmer number or Arabic numeral\n      isDefault = false;\n\n      // if spelled out already, convert to numeral\n      word = Helpers.convertToKhmerNumeral(secondWordData.word);\n\n      endTime = secondWordData.endTime;\n      confidence =\n        [wordData, secondWordData].reduce(\n          (acc, val) => acc + val.confidence,\n          0\n        ) / 2;\n      originalWordData = { wordData, secondWordData };\n      tags.push(\"combined\");\n      tags.push(\"preceded-by-nbsp\");\n      tags.push(\"followed-by-nbsp\");\n      tags.push(\"numeral\");\n\n      // skip next word since we're combining them\n      i += 1;\n    } else if (Helpers.KHMER_NUMBERS.includes(wordData.word)) {\n      // sometimes they spell it for us. In which case, just add the right tag\n      isDefault = false;\n      tags.push(\"spelled-out-number\");\n    } else if (wordData.word.match(/\\d/)) {\n      isDefault = false;\n      // means the previous word was not the Khmer word for number, since we already ruled this\n      // out, so hopefully speaker wants it\n      // spelled out\n\n      // sometimes there are non-number parts included on the same word...shame on you Google!\n      // For example, 2020_05_04_19_31_55.flac\n      // But need to keep that part separate\n      // find only the number, in case they mixed letters in the same word\n      let numberMatch = wordData.word.match(/^[^\\d]*(\\d+)[^\\d]*$/);\n      // make sure numberMatch is not null\n      // TODO test this more to make sure there aren't cases to make sure we cover here\n      let number = numberMatch ? numberMatch[1] : wordData.word.match(/\\d/);\n\n      if (wordData.word.length > 1) {\n        // just use numeral anyways\n        word = Helpers.convertToKhmerNumeral(number);\n        tags.push(\"numeral\");\n        tags.push(\"preceded-by-nbsp\");\n        tags.push(\"followed-by-nbsp\");\n      } else {\n        // spell it out\n        word = Helpers.KHMER_NUMBERS[number];\n        tags.push(\"spelled-out-number\");\n      }\n\n      // add the rest back in\n      let nonNumbers = wordData.word.match(new RegExp(`^(.*)?${number}(.*)?$`));\n      if (nonNumbers[1] || nonNumbers[2]) {\n        tags.push(\"letters-and-numbers-in-one\");\n\n        if (nonNumbers[1]) {\n          word = nonNumbers[1] + word;\n        }\n        if (nonNumbers[2]) {\n          word = word + nonNumbers[2];\n        }\n      }\n    } else if (Helpers.multiwordPunctuationMatch(words, i)) {\n      // checks if matches punctuations where their commands are more than one word\n      // it's a little slower to have to call twice, but only runs twice if there's a match, which\n      // shouldn't be that often, and it makes for relatively clean code.\n      // Could probably improve this too though\n      isDefault = false;\n      let match = Helpers.multiwordPunctuationMatch(words, i);\n      word = match.punctuation;\n\n      tags.push(\"multiword-punctuation\");\n      tags.push(\"punctuation\");\n\n      endTime = match.endTime;\n      confidence = match.averageConfidence;\n      originalWordData = match.originalWordData;\n\n      i += match.multiwordLength;\n    } else if (Helpers.PREFERRED_SPELLINGS[wordData.word]) {\n      // NOTE this should always be second to last check. Otherwise we want to change the word to a punctuation/number\n      isDefault = false;\n      let preferredSpelling = Helpers.PREFERRED_SPELLINGS[wordData.word];\n      console.log(\"found alt spelling\", wordData, preferredSpelling);\n      word = preferredSpelling;\n      tags.push(\"corrected-spelling\");\n    } else if (Helpers.isEnglish(wordData)) {\n      // NOTE this should always be last check. Otherwise we want to change the word to a punctuation/number\n      // English words should have spaces.\n      // Other than that can be default\n      tags.push(\"English\");\n      tags.push(\"preceded-by-nbsp\");\n      tags.push(\"followed-by-nbsp\");\n    }\n\n    if (isDefault) {\n      // word is ready to be used as is\n      tags.push(\"default\");\n    }\n\n    if (tags.includes(\"punctuation\")) {\n      if (PUNCTUATION_EXTRA_TAGS[word]) {\n        tags = tags.concat(PUNCTUATION_EXTRA_TAGS[word]);\n      }\n    }\n\n    let processedWordData = {\n      originalWordData,\n      word,\n      confidence,\n      endTime,\n      startTime,\n      tags,\n      // keep prev and next word unprocessed...or else we get into trouble with combined phrases\n      //prevWordData: i > 0 ? words[i-1] : null,\n      //nextWordData,\n    };\n    ret.push(processedWordData);\n  }\n\n  return ret;\n}\n","import React, { Component } from \"react\";\n// import getAudio from './getAudio'\nimport SpeechRecognition from \"../updated-react-speech-recognition/src/\";\nimport {\n  secondsToTimecode,\n  timecodeToSeconds,\n} from \"../Util/timecode-converter/index\";\nimport \"./style.css\";\n\nimport { Editor, EditorState, SelectionState, Modifier } from \"draft-js\";\nimport { combineKeywords } from \"./helpers/combine-keywords\";\nimport { split } from \"split-khmer\";\nimport Helpers from \"./helpers/khmer-helpers\";\n\n/*\nconst propTypes = {\n  // Props injected by SpeechRecognition\n  transcript: PropTypes.string,\n  resetTranscript: PropTypes.func,\n  browserSupportsSpeechRecognition: PropTypes.bool\n}\n*/\n\nconst manualFixes = [\n  {\n    modified: \"សេចក**ី\",\n    target: \"សេចក្ដី\",\n  },\n  {\n    modified: \"ក**ៅ\",\n    target: \"ក្ដៅ\",\n  },\n];\n\nclass GenerateTranscript extends Component {\n  constructor(props) {\n    super(props);\n    const editorState = EditorState.createEmpty();\n    this.state = {\n      error: \"\",\n      words: [],\n      editorState: EditorState.moveFocusToEnd(editorState),\n      oldWords: [],\n      oldEditorState: null,\n      replacer: {},\n      shouldAddSpace: false,\n    };\n    this.onChange = (editorState) => this.setState({ editorState });\n    this.pause = this.pause.bind(this);\n    this.start = this.start.bind(this);\n    this.reset = this.reset.bind(this);\n    this.copy = this.copy.bind(this);\n    this.undo = this.undo.bind(this);\n\n    // props.recognition.onresult\n    // set default language to Khmer TODO add options?\n    // https://www.science.co.il/language/Locale-codes.php for codes\n    props.recognition.lang = \"KM\";\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    if (\n      props.transcriptData &&\n      props.transcriptData.words.length > state.words.length\n    ) {\n      const sentence =\n        props.transcriptData.words[props.transcriptData.words.length - 1];\n\n      try {\n        let phrase = sentence.word;\n        let textToAdd = \"\";\n        if (props.recognition.lang === \"KM\") {\n          manualFixes.forEach((modifier) => {\n            phrase = phrase.replace(modifier.modified, modifier.target);\n          });\n\n          const splitWords = combineKeywords(\n            split(phrase).map((word) => {\n              return {\n                ...sentence,\n                word: Helpers.PREFERRED_SPELLINGS[word] || state.replacer[word] || word,\n              };\n            })\n          );\n          textToAdd = splitWords\n            .map((word) => word.word)\n            .join(Helpers.ZERO_WIDTH_SPACE);\n        } else {\n          textToAdd = phrase\n            .split(\" \")\n            .map((word) => state.replacer[word] || word)\n            .join(\" \");\n        }\n        textToAdd += state.shouldAddSpace ? \" \" : \"\";\n        const currentContent = state.editorState.getCurrentContent();\n\n        // create new selection state where focus is at the end\n        const selection = state.editorState.getSelection();\n        //insert text at the selection created above\n        const textWithInsert = Modifier.insertText(\n          currentContent,\n          selection,\n          textToAdd,\n          null\n        );\n        const newEditorState = EditorState.push(\n          state.editorState,\n          textWithInsert,\n          \"insert-characters\"\n        );\n\n        return {\n          ...state,\n          editorState: newEditorState,\n          words: [...props.transcriptData.words],\n        };\n      } catch (e) {\n        console.error(e);\n        return {\n          ...state,\n          error: \"Could not add \" + sentence.word,\n        };\n      }\n    }\n\n    return null;\n  }\n\n\n  reset(e) {\n    this.props.stopListening();\n    this.props.resetTranscript();\n    const editorState = EditorState.createEmpty();\n    this.setState({\n      error: \"\",\n      editorState: EditorState.moveFocusToEnd(editorState),\n      words: [],\n      oldEditorState: this.state.editorState,\n      oldWords: this.state.words,\n    });\n  }\n\n  start(e) {\n    this.props.startListening();\n  }\n\n  pause(e) {\n    this.props.stopListening();\n  }\n\n  copy(e) {\n    const text = this.state.editorState.getCurrentContent().getPlainText();\n    var input = document.createElement(\"input\");\n    input.setAttribute(\"value\", text);\n    document.body.appendChild(input);\n    input.select();\n    var result = document.execCommand(\"copy\");\n    document.body.removeChild(input);\n    return result;\n  }\n  undo(e) {\n    this.setState({\n      ...this.state,\n      oldEditorState: null,\n      oldWords: null,\n      editorState: this.state.oldEditorState,\n      words: this.state.oldWords,\n    });\n  }\n  render() {\n    const {\n      transcript,\n      browserSupportsSpeechRecognition,\n      // interimTranscript,\n      listening,\n      // allResults\n    } = this.props;\n\n    if (!browserSupportsSpeechRecognition) {\n      // NOTE happens several times, as this gets rerendered for some reason. Returns false even when browser can support sometimes for some reason too, but eventually returns true\n      return null;\n    }\n    //TODO add back in once we switch over to using my fork  which passes down all results as an array rather than compiling all into a string\n\n    return (\n      <div>\n        <h1>Speech Recognition v2.0.6</h1>\n        <select\n          onChange={(e) => {\n            this.props.recognition.lang = e.target.value;\n          }}\n          defaultValue={this.props.recognition.lang}\n          data-placeholder=\"Choose a Language...\"\n        >\n          <option value=\"AF\">Afrikaans</option>\n          <option value=\"SQ\">Albanian</option>\n          <option value=\"AR\">Arabic</option>\n          <option value=\"HY\">Armenian</option>\n          <option value=\"EU\">Basque</option>\n          <option value=\"BN\">Bengali</option>\n          <option value=\"BG\">Bulgarian</option>\n          <option value=\"CA\">Catalan</option>\n          <option value=\"KM\">Cambodian</option>\n          <option value=\"ZH\">Chinese (Mandarin)</option>\n          <option value=\"HR\">Croatian</option>\n          <option value=\"CS\">Czech</option>\n          <option value=\"DA\">Danish</option>\n          <option value=\"NL\">Dutch</option>\n          <option value=\"EN\">English</option>\n          <option value=\"ET\">Estonian</option>\n          <option value=\"FJ\">Fiji</option>\n          <option value=\"FI\">Finnish</option>\n          <option value=\"FR\">French</option>\n          <option value=\"KA\">Georgian</option>\n          <option value=\"DE\">German</option>\n          <option value=\"EL\">Greek</option>\n          <option value=\"GU\">Gujarati</option>\n          <option value=\"HE\">Hebrew</option>\n          <option value=\"HI\">Hindi</option>\n          <option value=\"HU\">Hungarian</option>\n          <option value=\"IS\">Icelandic</option>\n          <option value=\"ID\">Indonesian</option>\n          <option value=\"GA\">Irish</option>\n          <option value=\"IT\">Italian</option>\n          <option value=\"JA\">Japanese</option>\n          <option value=\"JW\">Javanese</option>\n          <option value=\"KO\">Korean</option>\n          <option value=\"LA\">Latin</option>\n          <option value=\"LV\">Latvian</option>\n          <option value=\"LT\">Lithuanian</option>\n          <option value=\"MK\">Macedonian</option>\n          <option value=\"MS\">Malay</option>\n          <option value=\"ML\">Malayalam</option>\n          <option value=\"MT\">Maltese</option>\n          <option value=\"MI\">Maori</option>\n          <option value=\"MR\">Marathi</option>\n          <option value=\"MN\">Mongolian</option>\n          <option value=\"NE\">Nepali</option>\n          <option value=\"NO\">Norwegian</option>\n          <option value=\"FA\">Persian</option>\n          <option value=\"PL\">Polish</option>\n          <option value=\"PT\">Portuguese</option>\n          <option value=\"PA\">Punjabi</option>\n          <option value=\"QU\">Quechua</option>\n          <option value=\"RO\">Romanian</option>\n          <option value=\"RU\">Russian</option>\n          <option value=\"SM\">Samoan</option>\n          <option value=\"SR\">Serbian</option>\n          <option value=\"SK\">Slovak</option>\n          <option value=\"SL\">Slovenian</option>\n          <option value=\"ES\">Spanish</option>\n          <option value=\"SW\">Swahili</option>\n          <option value=\"SV\">Swedish </option>\n          <option value=\"TA\">Tamil</option>\n          <option value=\"TT\">Tatar</option>\n          <option value=\"TE\">Telugu</option>\n          <option value=\"TH\">Thai</option>\n          <option value=\"BO\">Tibetan</option>\n          <option value=\"TO\">Tonga</option>\n          <option value=\"TR\">Turkish</option>\n          <option value=\"UK\">Ukrainian</option>\n          <option value=\"UR\">Urdu</option>\n          <option value=\"UZ\">Uzbek</option>\n          <option value=\"VI\">Vietnamese</option>\n          <option value=\"CY\">Welsh</option>\n          <option value=\"XH\">Xhosa</option>\n        </select>\n        <button\n          disabled={!this.state.oldEditorState}\n          onClick={this.undo}\n          onMouseDown={(e) => e.preventDefault()}\n        >\n          Undo\n        </button>\n        <button onClick={this.reset} onMouseDown={(e) => e.preventDefault()}>\n          Reset\n        </button>\n        <button onClick={this.start} onMouseDown={(e) => e.preventDefault()}>\n          Start\n        </button>\n        <button onClick={this.pause} onMouseDown={(e) => e.preventDefault()}>\n          Pause\n        </button>\n        <button onClick={this.copy} onMouseDown={(e) => e.preventDefault()}>\n          Copy\n        </button>\n        <label>\n          Should add space?:\n          <input\n            name=\"isGoing\"\n            type=\"checkbox\"\n            checked={this.state.shouldAddSpace}\n            onChange={(e) => {\n              this.setState({ shouldAddSpace: !this.state.shouldAddSpace });\n            }}\n          />\n        </label>\n\n        {/* <button disabled={!this.props.finalTranscript || this.props.finalTranscript !== this.props.transcript} onClick={this.stop} onMouseDown={e => e.preventDefault()}>Insert</button> */}\n        <br />\n        <div className=\"transcript-container\">\n          In progress:{\" \"}\n          {this.props.finalTranscript !== this.props.transcript\n            ? this.props.interimTranscript\n            : \"\"}{\" \"}\n          ...\n          <br />\n          {this.state.error && (\n            <span style={{ color: \"red\" }}>{this.state.error}</span>\n          )}\n        </div>\n        {listening ? (\n          <span>\n            *Listening* Total Time Elapsed:{\" \"}\n            {secondsToTimecode(this.props.totalTimeElapsed)}\n          </span>\n        ) : (\n          <div>&nbsp;</div>\n        )}\n        <Editor editorState={this.state.editorState} onChange={this.onChange} />\n        <label>Replacer: </label>\n        <textarea style={{width: \"400px\"}} placeholder='Ex. {\"target\": \"modifier\", \"target2\": \"modifier2\"}' onChange={(e) => {\n          try { \n            const newReplacer = JSON.parse(e.target.value);\n            this.setState({replacer: newReplacer});\n          }\n          catch(e){\n            this.setState({replacer: {}});\n          }\n        }} />\n        {false && (\n          <div>\n            <p>Volume</p>\n            <input\n              id=\"volume\"\n              type=\"range\"\n              min=\"0\"\n              max=\"1\"\n              step=\"0.1\"\n              value=\"0.5\"\n            />\n          </div>\n        )}\n      </div>\n    );\n  }\n}\n\n// GenerateTranscript.propTypes = propTypes\n\nconst options = {\n  autoStart: false,\n};\nexport default SpeechRecognition(options)(GenerateTranscript);\n","import React from \"react\";\nimport { render } from \"react-dom\";\n\nimport { TranscriptEditor, GenerateTranscript } from \"./lib\";\n\nimport kaldiTedTalkTranscript from \"./sample-data/KateDarling_2018S-bbc-kaldi.json\";\nimport khmerRougeTranscript from \"./sample-data/khmer-rouge-interview-data.json\";\nimport style from \"./index.module.css\";\nimport SttTypeSelect from \"./select-stt-json-type\";\nimport ExportFormatSelect from \"./select-export-format\";\n\n// import khmerRougeInterviewTranscript from './sample-data/khmer-rouge-interview-transcript-data.json';\n\nconst tedTalkVideoUrl =\n  \"https://download.ted.com/talks/KateDarling_2018S-950k.mp4\";\nconst khmerRougeInterviewTranscript =\n  \"https://av.voanews.com/Videoroot/Pangeavideo/2019/01/b/b8/b83b37e5-3deb-4668-9daa-b2837648799f.mp4?download=1\"; // 360px (270, 720, and 1080 available)\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      transcriptData: null,\n      mediaUrl: null,\n      isTextEditable: true,\n      sttType: \"bbckaldi\",\n      analyticsEvents: [],\n      fileName: \"Khmer Transcript Data\",\n      playingWhileListening: false,\n    };\n\n    this.transcriptEditorRef = React.createRef();\n    this.startListeningAndPlayingMedia = this.startListeningAndPlayingMedia.bind(\n      this\n    );\n  }\n\n  loadDemo() {\n    this.setState({\n      transcriptData: khmerRougeTranscript,\n      mediaUrl: khmerRougeInterviewTranscript,\n      sttType: \"bbckaldi\",\n      fileName: \"transcript-data\",\n    });\n  }\n\n  startListeningAndPlayingMedia(e) {\n    this.setState({ playingWhileListening: true });\n  }\n\n  // https://stackoverflow.com/questions/8885701/play-local-hard-drive-video-file-with-html5-video-tag\n  handleChangeLoadMedia(files) {\n    console.log(files);\n    const file = files[0];\n    const type = file.type;\n    // check if is playable\n    const videoNode = document.createElement(\"video\");\n    const canPlay = videoNode.canPlayType(type);\n    if (canPlay) {\n      const fileURL = URL.createObjectURL(file);\n      // videoNode.src = fileURL\n      this.setState({\n        // transcriptData: kaldiTedTalkTranscript,\n        mediaUrl: fileURL,\n        fileName: file.name,\n      });\n    } else {\n      alert(\"select a valid audio or video file\");\n    }\n  }\n\n  handleChangeLoadMediaUrl() {\n    const fileURL = prompt(\"Paste the URL you'd like to use here\");\n\n    this.setState({\n      // transcriptData: kaldiTedTalkTranscript,\n      mediaUrl: fileURL,\n    });\n  }\n\n  handleChangeLoadTranscriptJson(files) {\n    const file = files[0];\n\n    if (file.type === \"application/json\") {\n      const fr = new FileReader();\n\n      fr.onload = (evt) => {\n        this.setState({\n          transcriptData: JSON.parse(evt.target.result),\n        });\n      };\n\n      fr.readAsText(file);\n    } else {\n      alert(\"select a valid json file\");\n    }\n  }\n\n  handleIsTextEditable = () => {\n    this.setState((prevState) => ({\n      isTextEditable: prevState.isTextEditable !== true,\n    }));\n  };\n\n  // https://stackoverflow.com/questions/21733847/react-jsx-selecting-selected-on-selected-select-option\n  handleSttTypeChange = (event) => {\n    console.log(event.target.name, event.target.value);\n    this.setState({ [event.target.name]: event.target.value });\n  };\n\n  handleExportFormatChange = (event) => {\n    console.log(event.target.name, event.target.value);\n    this.setState({ [event.target.name]: event.target.value });\n  };\n\n  exportTranscript = () => {\n    // eslint-disable-next-line react/no-string-refs\n    const { data, ext } = this.transcriptEditorRef.current.getEditorContent(\n      this.state.exportFormat\n    );\n    this.download(data, `${this.state.mediaUrl}.${ext}`);\n  };\n\n  // https://stackoverflow.com/questions/2897619/using-html5-javascript-to-generate-and-save-a-file\n  download = (content, filename, contentType) => {\n    const type = contentType || \"application/octet-stream\";\n    const a = document.createElement(\"a\");\n    const blob = new Blob([content], { type: type });\n\n    a.href = window.URL.createObjectURL(blob);\n    a.download = filename;\n    a.click();\n  };\n\n  clearLocalStorage = () => {\n    localStorage.clear();\n    console.info(\"cleared local storage\");\n  };\n\n  handleAnalyticsEvents = (event) => {\n    this.setState({ analyticsEvents: [...this.state.analyticsEvents, event] });\n  };\n\n  handleChangeTranscriptName = (value) => {\n    this.setState({ fileName: value });\n  };\n\n  playMedia;\n  render() {\n    return (\n      <div className={style.container}>\n        <span className={style.title}>\n          Demo page for <mark>Khmer Transcript Creator</mark> - Component\n          |&nbsp;\n          <a\n            href=\"https://github.com/RyanQuey/khmer-react-transcript-creator\"\n            rel=\"noopener noreferrer\"\n            target=\"_blank\"\n          >\n            Github Repo\n          </a>\n        </span>\n        <GenerateTranscript />\n      </div>\n    );\n  }\n}\n\nrender(<App />, document.getElementById(\"root\"));\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"src_container__Q_z2T\"};"],"sourceRoot":""}