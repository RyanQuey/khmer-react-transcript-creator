{"version":3,"sources":["lib/updated-react-speech-recognition/src/index.js","lib/updated-react-speech-recognition/src/SpeechRecognition.js","lib/Util/timecode-converter/secondsToTimecode.js","lib/GenerateTranscript/helpers/book-names.js","lib/GenerateTranscript/helpers/khmer-helpers.js","lib/GenerateTranscript/helpers/combine-keywords.js","lib/GenerateTranscript/index.js","index.js","index.module.css"],"names":["SpeechRecognition","options","SpeechRecognitionInner","WrappedComponent","listening","BrowserSpeechRecognition","window","SpeechRecognitionAlternative","webkitSpeechRecognition","mozSpeechRecognition","msSpeechRecognition","oSpeechRecognition","recognition","browserSupportsSpeechRecognition","autoStart","start","pauseAfterDisconnect","interimTranscript","finalTranscript","newTranscriptData","status","wonid","punct","words","_Component","SpeechRecognitionContainer","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","minElapsed","Date","now","state","speechTimerStartedAt","newWordData","wordResults","transcript","allWordData","transcriptData","length","end","toLowerCase","replace","confidence","word","index","onRecognitionDisconnect","setState","startListening","updateTranscript","event","newState","allResults","results","console","log","i","resultIndex","isFinal","concatTranscripts","push","resetTranscript","disconnect","DOMException","abortListening","stopListening","inherits","createClass","key","value","continuous","interimResults","onresult","bind","onend","disconnectType","abort","stop","_len","arguments","transcriptParts","Array","_key","map","t","trim","join","totalTimeElapsed","react_default","a","createElement","assign","Component","secondsToTimecode","seconds","framePerSeconds","fps","undefined","normalisedSeconds","Number","Math","floor","toPrecision","toFixed","normalisePlayerTime","wholeSeconds","frames","_padZero","n","concat","parseInt","BOOKS_STR","BOOKS_ARR","_nums","BOOKS_WITH_MANY","filter","b","includes","BOOKS_WITH_MANY_NO_NUM","_","uniq","substring","ALL_BOOKS_NO_NUM","bookNames","KHMER_NUMBERS","KHMER_NUMERALS","KHMER_PUNCTUATION_NO_LEADER","ល៉ៈ ","KHMER_PUNCTUATION_NO_LEADER_KEYS","keys","KHMER_PUNCTUATION","ខណ្ឌ","ខ័ណ្ឌ","។","សួរ","ឧទាន","MULTI_WORD_KHMER_PUNCTUATION","(",")","៖","«","»","KHMER_PUNCTUATION_KEYS","ALL_KHMER_PUNCTUATION","bonusOrdinals","khOrdinalIndicatorArr","isNumber","str","match","khmer_helpers","khPart","khOrdinalIndicatorRegEx","RegExp","khOrdinalRegEx","khNumber","khChapter","khChapterRegex","khVerse","khVerseRegex","referencesRegex","khmerNumberRegex","nonGlobalRegex","reg","source","convertToKhmerNumeral","numStr","ret","spelledOutIndex","indexOf","punctuationRegex","preferredSpellingRegex","PREFERRED_SPELLINGS","khPunctuationLeader","isEnglish","wordData","ZERO_WIDTH_SPACE","isOrdinal","word1","word2","wordIsFollowedBySpace","nextWordData","tags","multiwordPunctuationMatch","allWords","currentIndex","some","valArr","every","wordToMatch","matchedWordsData","range","punctuation","multiwordLength","originalWordData","averageConfidence","reduce","acc","val","endTime","last","secondWordData","thirdWordData","fourthWordData","PUNCTUATION_EXTRA_TAGS","?","!","manualFixes","modified","target","languages","GenerateTranscript","editorState","EditorState","createEmpty","error","moveFocusToEnd","oldWords","oldEditorState","replacer","replacerTextareaValue","shouldAddSpace","onChange","pause","assertThisInitialized","reset","copy","undo","resplit","changeReplacerHook","setReplacerLocalStorage","getReplacerFromLocalStorage","lang","e","preventDefault","text","getCurrentContent","getPlainText","input","document","setAttribute","body","appendChild","select","result","execCommand","removeChild","objectSpread","localStorageKey","retrievedReplacer","localStorage","getItem","newReplacer","setItem","err","replacerValue","JSON","parse","Helpers","textToAdd","split","newEditorState","createWithContent","ContentState","createFromText","_this2","_this$props","defaultValue","data-placeholder","disabled","onClick","name","type","checked","className","style","color","Draft","width","placeholder","sentence","phrase","forEach","modifier","startTime","isDefault","num","numberMatch","number","nonNumbers","preferredSpelling","processedWordData","combineKeywords","currentContent","selection","getSelection","textWithInsert","Modifier","insertText","toConsumableArray","App","handleIsTextEditable","prevState","isTextEditable","handleSttTypeChange","defineProperty","handleExportFormatChange","exportTranscript","_this$transcriptEdito","transcriptEditorRef","current","getEditorContent","exportFormat","data","ext","download","mediaUrl","content","filename","contentType","blob","Blob","href","URL","createObjectURL","click","clearLocalStorage","clear","info","handleAnalyticsEvents","analyticsEvents","handleChangeTranscriptName","fileName","sttType","playingWhileListening","React","createRef","startListeningAndPlayingMedia","khmerRougeTranscript","files","file","canPlayType","fileURL","alert","prompt","fr","FileReader","onload","evt","readAsText","container","title","rel","lib_GenerateTranscript","render","src_App","getElementById","module","exports"],"mappings":"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","file":"static/js/main.967a4728.chunk.js","sourcesContent":["import SpeechRecognition from './SpeechRecognition'\n\nexport default SpeechRecognition\n","import React, { Component } from 'react'\n\nexport default function SpeechRecognition(options) {\n  const SpeechRecognitionInner = function (WrappedComponent) {\n    const BrowserSpeechRecognition =\n      typeof window !== 'undefined' &&\n      (window.SpeechRecognitionAlternative ||\n        window.webkitSpeechRecognition ||\n        window.mozSpeechRecognition ||\n        window.msSpeechRecognition ||\n        window.oSpeechRecognition)\n    const recognition = BrowserSpeechRecognition\n      ? new BrowserSpeechRecognition()\n      : null\n    const browserSupportsSpeechRecognition = recognition !== null\n    let listening\n    if (\n      !browserSupportsSpeechRecognition ||\n      (options && options.autoStart === false)\n    ) {\n      listening = false\n    } else {\n      recognition.start()\n      listening = true\n    }\n    let pauseAfterDisconnect = false\n    let interimTranscript = ''\n    let finalTranscript = ''\n\n    // TODO put this as the retval key using template found in src/sample-data/KateDarling_2018S-bbc-kaldi.json\n    const newTranscriptData = () => ({\n      status: true,\n      wonid: \"octo:2692ea33-d595-41d8-bfd5-aa7f2d2f89ee\", // don't know this one, probably will generate something\n      punct: \"\", // total transcript of all the words TODO currently not setting\n      words: [], // array of newWordData objects\n    })\n    \n\n    return class SpeechRecognitionContainer extends Component {\n      constructor(props) {\n        super(props)\n\n        this.state = {\n          interimTranscript,\n          finalTranscript,\n          transcriptData: {},\n          listening: false,\n          allResults: [],\n          speechTimerStartedAt: false, // ms since Jan 1 1970\n        }\n\n        // TODO do the binding thing so don't have to do the crazy arrow funcs here\n      }\n\n      componentWillMount() {\n        if (recognition) {\n          recognition.continuous = false // originally set to true, but this breaks up the words into smaller fragments much better\n          recognition.interimResults = true\n          recognition.onresult = this.updateTranscript.bind(this)\n          recognition.onend = this.onRecognitionDisconnect.bind(this)\n          // onspeechstart/end or onsoundstart/end might be useful\n          /*\n    recognition.onspeechend = () => {console.log(\"speech is now ending\")}\n    recognition.onspeechstart = () => {console.log(\"speech is now starting\")}\n    recognition.onsoundstart = () => {console.log(\"sound is now starting\")}\n    recognition.onsoundend = () => {console.log(\"sound is now ending\")}\n    recognition.nomatch = () => {console.log(\"no match!!!11\")}\n    recognition.onboundary = () => {console.log(\"boundary found!\")}\n    recognition.onresume = () => {console.log(\"resume found!\")}\n    recognition.onmark = () => {console.log(\"mark found!\")}\n    recognition.onpause = () => {console.log(\"pause found!\")}\n    */\n          this.setState({\n            listening,\n            transcriptData: newTranscriptData()\n          })\n        }\n      }\n\n      disconnect (disconnectType) {\n        if (recognition) {\n          switch (disconnectType) {\n            case 'ABORT':\n              pauseAfterDisconnect = true\n              recognition.abort()\n              break\n            case 'RESET':\n              pauseAfterDisconnect = true\n              recognition.abort()\n              break\n            case 'STOP':\n            default:\n              pauseAfterDisconnect = true\n              recognition.stop()\n          }\n        }\n      }\n\n      // minutes elapsed since started.\n      minElapsed = () => {\n        return (Date.now() - this.state.speechTimerStartedAt)/1000;\n      }\n\n      newWordData = (wordResults) => {\n        const words = wordResults.transcript;\n        // remove all punctuation and lowercase it\n        const allWordData = this.state.transcriptData.words;\n        const start = allWordData.length > 0 ? allWordData[allWordData.length - 1].end : 0;\n        const end = this.minElapsed();\n        const punct = words.toLowerCase().replace(/[.,\\/#!$%\\^&\\*;:{}=\\-_`~()]/g, '');\n\n        // format required for the bbc lib\n        return {\n          start, // time in minutes, using decimals not seconds, eg 13.02 (float)\n          confidence: wordResults.confidence, // %, out of 1, eg 0.68 (float)\n          end, // end time in min\n          word: words, // all words, not formatted (and lowercase), eg \"there\" (string)\n          punct, // word, as displayed, eg \"There\" (string)\n          index: allWordData.length,\n        }\n      }\n\n      onRecognitionDisconnect = () => {\n        listening = false\n        if (pauseAfterDisconnect) {\n          this.setState({ listening })\n        } else {\n          this.startListening()\n        }\n        pauseAfterDisconnect = false\n      }\n\n      // TODO might stop getting interim results and handling them if it hurts performance\n      updateTranscript = (event) => {\n        interimTranscript = ''\n        // looks like they iterate over same results every time, rather than gradually compiling as it goes. Could slow things down if transcript gets long TODO\n        let newState = {\n          // might not need\n          allResults: event.results\n        }\n        console.log(event);\n        for (let i = event.resultIndex; i < event.results.length; ++i) {\n          if (event.results[i].isFinal) {\n            let wordResults = event.results[i][0]\n            finalTranscript = this.concatTranscripts(\n              finalTranscript,\n              wordResults.transcript\n            )\n\n            let newWordData = this.newWordData(wordResults)\n            //TODO bad practice modifying original object like this!\n            let transcriptData = this.state.transcriptData\n            transcriptData.words.push(newWordData)\n            \n            newState.finalTranscript = finalTranscript\n            newState.transcriptData = transcriptData\n\n          } else {\n            interimTranscript = this.concatTranscripts(\n              interimTranscript,\n              event.results[i][0].transcript\n            )\n            newState.interimTranscript = interimTranscript\n          }\n        }\n\n        this.setState(newState)\n      }\n\n      // returns string with all transcript together\n      concatTranscripts(...transcriptParts) {\n        return transcriptParts.map(t => t.trim()).join(' ').trim()\n      }\n\n      resetTranscript = () => {\n        interimTranscript = ''\n        finalTranscript = ''\n        this.disconnect('RESET')\n        this.setState({ \n          interimTranscript, \n          finalTranscript,\n          transcriptData: newTranscriptData(),\n          speechTimerStartedAt: false,\n        })\n      }\n\n      startListening = () => {\n        if (recognition && !listening) {\n          try {\n            recognition.start()\n          } catch (DOMException) {\n            // Tried to start recognition after it has already started - safe to swallow this error\n          }\n          listening = true\n          let newState = {listening}\n          if (!this.state.speechTimerStartedAt) {\n            newState.speechTimerStartedAt = Date.now()\n          }\n\n          this.setState(newState)\n        }\n      }\n\n      abortListening = () => {\n        listening = false\n        this.setState({ listening })\n        this.disconnect('ABORT')\n      }\n\n      stopListening = () => {\n        listening = false\n        this.setState({ listening })\n        this.disconnect('STOP')\n      }\n\n      render() {\n        // includes both\n        const transcript = this.concatTranscripts(\n          finalTranscript,\n          interimTranscript\n        )\n\n        const totalTimeElapsed = this.minElapsed()\n\n        return (\n          <WrappedComponent\n            resetTranscript={this.resetTranscript}\n            startListening={this.startListening}\n            abortListening={this.abortListening}\n            stopListening={this.stopListening}\n            transcript={transcript}\n            recognition={recognition}\n            allResults={this.state.allResults}\n            listening={this.state.listening}\n            transcriptData={this.state.transcriptData}\n            interimTranscript={this.state.interimTranscript}\n            finalTranscript={this.state.finalTranscript}\n            browserSupportsSpeechRecognition={browserSupportsSpeechRecognition}\n            totalTimeElapsed={totalTimeElapsed}\n            {...this.props} />\n        )\n      }\n    }\n  }\n\n  if (typeof options === 'function') {\n    return SpeechRecognitionInner(options)\n  } else {\n    return SpeechRecognitionInner\n  }\n}\n","/**\n* Raised in this comment https://github.com/bbc/react-transcript-editor/pull/9\n* abstracted from https://github.com/bbc/newslabs-cdn/blob/master/js/20-bbcnpf.utils.js\n* In broadcast VIDEO, timecode is NOT hh:mm:ss:ms, it's hh:mm:ss:ff where ff is frames,\n* dependent on the framerate of the media concerned.\n* `hh:mm:ss:ff`\n*/\n\n/**\n * Helper function\n * Rounds to the 14milliseconds boundaries\n * Time in video can only \"exist in\" 14milliseconds boundaries.\n * This makes it possible for the HTML5 player to be frame accurate.\n * @param {*} seconds\n * @param {*} fps\n */\nconst normalisePlayerTime = function (seconds, fps) {\n  return Number((1.0 / fps * Math.floor(Number((fps * seconds).toPrecision(12)))).toFixed(2));\n};\n\n/*\n* @param {*} seconds\n* @param {*} fps\n*/\nconst secondsToTimecode = function (seconds, framePerSeconds) {\n  // written for PAL non-drop timecode\n  let fps = 25;\n  if (framePerSeconds !== undefined) {\n    fps = framePerSeconds;\n  }\n\n  const normalisedSeconds = normalisePlayerTime(seconds, fps);\n\n  const wholeSeconds = Math.floor(normalisedSeconds);\n  const frames = ((normalisedSeconds - wholeSeconds) * fps).toFixed(2);\n\n  // prepends zero - example pads 3 to 03\n  function _padZero(n) {\n    if (n < 10) return `0${ parseInt(n) }`;\n\n    return parseInt(n);\n  }\n\n  return `${ _padZero((wholeSeconds / 60 / 60) % 60)\n  }:${\n    _padZero((wholeSeconds / 60) % 60)\n  }:${\n    _padZero(wholeSeconds % 60)\n  }:${\n    _padZero(frames) }`;\n};\n\nexport default secondsToTimecode;\n","import _ from \"lodash\";\n\nexport const BOOKS_STR =\n  \"លោកុប្បត្តិ,និក្ខមនំ,លេវីវិន័យ,ជនគណនា,ទុតិយកថា,យ៉ូស្វេ,ចៅហ្វាយ,នាង​រស់,១ សាំយូអែល,២ សាំយូអែល,១ ពង្សាវតារក្សត្រ,២ ពង្សាវតារក្សត្រ,១ របាក្សត្រ,២ របាក្សត្រ,អែសរ៉ា,នេហេមា,នាង​អេសធើរ,យ៉ូប,ទំនុកតម្កើង,សុភាសិត,សាស្ដា,បទ​ចំរៀង,អេសាយ,យេរេមា,បរិទេវ,អេសេគាល,ដានីយ៉ែល,ហូសេ,យ៉ូអែល,អេម៉ុស,អូបាឌា,យ៉ូណាស,មីកា,ណាហ៊ូម,ហាបាគូក,សេផានា,ហាកាយ,សាការី,ម៉ាឡាគី,ម៉ាថាយ,ម៉ាកុស,លូកា,យ៉ូហាន,កិច្ចការ,រ៉ូម,១ កូរិនថូស,២ កូរិនថូស,កាឡាទី,អេភេសូ,ភីលីព,កូឡូស,១ ថេស្សាឡូនិក,២ ថេស្សាឡូនិក,១ ធីម៉ូថេ,២ ធីម៉ូថេ,ទីតុស,ភីលេម៉ូន,ហេប្រឺ,យ៉ាកុប,១ ពេត្រុស,២ ពេត្រុស,១ យ៉ូហាន,២ យ៉ូហាន,៣ យ៉ូហាន,យូដាស,វិវរណៈ\";\nexport const BOOKS_ARR = [\n  \"លោកុប្បត្តិ\",\n  \"និក្ខមនំ\",\n  \"លេវីវិន័យ\",\n  \"ជនគណនា\",\n  \"ទុតិយកថា\",\n  \"យ៉ូស្វេ\",\n  \"ចៅហ្វាយ\",\n  \"នាង​រស់\",\n  \"១ សាំយូអែល\",\n  \"២ សាំយូអែល\",\n  \"១ ពង្សាវតារក្សត្រ\",\n  \"២ ពង្សាវតារក្សត្រ\",\n  \"១ របាក្សត្រ\",\n  \"២ របាក្សត្រ\",\n  \"អែសរ៉ា\",\n  \"នេហេមា\",\n  \"នាង​អេសធើរ\",\n  \"យ៉ូប\",\n  \"ទំនុកតម្កើង\",\n  \"សុភាសិត\",\n  \"សាស្ដា\",\n  \"បទ​ចំរៀង\",\n  \"អេសាយ\",\n  \"យេរេមា\",\n  \"បរិទេវ\",\n  \"អេសេគាល\",\n  \"ដានីយ៉ែល\",\n  \"ហូសេ\",\n  \"យ៉ូអែល\",\n  \"អេម៉ុស\",\n  \"អូបាឌា\",\n  \"យ៉ូណាស\",\n  \"មីកា\",\n  \"ណាហ៊ូម\",\n  \"ហាបាគូក\",\n  \"សេផានា\",\n  \"ហាកាយ\",\n  \"សាការី\",\n  \"ម៉ាឡាគី\",\n  \"ម៉ាថាយ\",\n  \"ម៉ាកុស\",\n  \"លូកា\",\n  \"យ៉ូហាន\",\n  \"កិច្ចការ\",\n  \"រ៉ូម\",\n  \"១ កូរិនថូស\",\n  \"២ កូរិនថូស\",\n  \"កាឡាទី\",\n  \"អេភេសូ\",\n  \"ភីលីព\",\n  \"កូឡូស\",\n  \"១ ថេស្សាឡូនិក\",\n  \"២ ថេស្សាឡូនិក\",\n  \"១ ធីម៉ូថេ\",\n  \"២ ធីម៉ូថេ\",\n  \"ទីតុស\",\n  \"ភីលេម៉ូន\",\n  \"ហេប្រឺ\",\n  \"យ៉ាកុប\",\n  \"១ ពេត្រុស\",\n  \"២ ពេត្រុស\",\n  \"១ យ៉ូហាន\",\n  \"២ យ៉ូហាន\",\n  \"៣ យ៉ូហាន\",\n  \"យូដាស\",\n  \"វិវរណៈ\",\n].concat([\n  // add some alt spellings that Google might send\n  \"១ ពង្សាវតាក្សត្រ\",\n  \"២ ពង្សាវតាក្សត្រ\",\n]);\n\nconst _nums = [\"១\", \"២\", \"៣\"];\n// TODO for performance don't run all this stuff on initialization, do it when it's called or\n// something\n// all the books that have more than one\nexport const BOOKS_WITH_MANY = BOOKS_ARR.filter((b) => _nums.includes(b[0]));\n// take away the number for them\nexport const BOOKS_WITH_MANY_NO_NUM = _.uniq(\n  BOOKS_WITH_MANY.map((b) => b.substring(2))\n);\nexport const ALL_BOOKS_NO_NUM = _.uniq(\n  BOOKS_ARR.map((b) => {\n    if (BOOKS_WITH_MANY.includes(b)) {\n      return b.substring(2);\n    } else {\n      return b;\n    }\n  })\n);\n","import PREFERRED_SPELLINGS from \"./preferred-spellings.json\";\nimport * as bookNames from \"./book-names\";\nimport _ from \"lodash\";\n\nconsole.log(bookNames);\n\n// make sure numbers correspond to index in array\nconst KHMER_NUMBERS = [\n  // numbers\n  \"សូន្យ\",\n  \"មួយ\",\n  \"ពីរ\",\n  \"បី\",\n  \"បួន\",\n  \"ប្រាំ\",\n  \"ប្រាំមួយ\",\n  \"ប្រាំពីរ\",\n  \"ប្រាំបី\",\n  \"ប្រាំបួន\",\n];\nconst KHMER_NUMERALS = [\n  // numbers\n  \"០\",\n  \"១\",\n  \"២\",\n  \"៣\",\n  \"៤\",\n  \"៥\",\n  \"៦\",\n  \"៧\",\n  \"៨\",\n  \"៩\",\n];\n\n// none of these will require \"sanna\" (kh for \"sign\") before recognizing it\nconst KHMER_PUNCTUATION_NO_LEADER = {\n  \"ល៉ៈ \": \"។ល។\",\n};\n// for performance want to only run once, not for every word in every transcript!\nconst KHMER_PUNCTUATION_NO_LEADER_KEYS = Object.keys(\n  KHMER_PUNCTUATION_NO_LEADER\n);\n\n// all of these will require \"sanna\" (kh for \"sign\") before recognizing it\nconst KHMER_PUNCTUATION = {\n  ខណ្ឌ: \"។ \",\n  ខ័ណ្ឌ: \"។ \",\n  // need this one too since sometimes they actually return this correctly, but we're having users\n  // say khPunctuationLeader bfeore it anyways...\n  \"។\": \"។ \",\n  សួរ: \"? \",\n  ឧទាន: \"! \",\n};\n// These are different. Keys will be what we want, values a list of the words.\n// Makes it easy to iterate over and check for matches\n// TODO for performance, don't iterate over same word \"bauk\" or \"bit\" every time!\nconst MULTI_WORD_KHMER_PUNCTUATION = {\n  // TODO test. Maybe google separates words differently for example\n  \"(\": [[\"បើក\", \"វង់\", \"ក្រចក\"]],\n  // TODO test. Maybe google separates words differently for example\n  \")\": [[\"បិត\", \"វង់\", \"ក្រចក\"]],\n  \"៖\": [[\"ចំណុច\", \"ពីរ\", \"គូស\"]],\n  \"«\": [\n    [\"បើក\", \"សញ្ញា\", \"អញ្ញ\", \"ប្រកាស\"],\n    // Google has read it this way before, so being flexible\n    [\"បើក\", \"សញ្ញា\", \"អាច\", \"ប្រកាស\"],\n    [\"សញ្ញា\", \"បើក\", \"អាច\", \"ប្រកាស\"],\n    [\"សញ្ញា\", \"បើក\", \"ៗ\", \"ប្រកាស\"],\n    [\"បើក\", \"សញ្ញា\", \"អញ្ញ\"],\n    // Google has read it this way before, so being flexible\n    [\"បើក\", \"សញ្ញា\", \"ៗ\"],\n    [\"សញ្ញា\", \"អញ្ញ\", \"បើក\"],\n    // Google has read it this way before, so being flexible\n    [\"សញ្ញា\", \"ៗ\", \"បើក\"],\n  ],\n  \"»\": [\n    // Google has read it this way before, so being flexible\n    [\"បិទ\", \"សញ្ញា\", \"អអាច\", \"ប្រកាស\"],\n    [\"បិទ\", \"សញ្ញា\", \"អញ្ញ\", \"ប្រកាស\"],\n    [\"សញ្ញា\", \"បិទ\", \"អញ្ញ\", \"ប្រកាស\"],\n    [\"សញ្ញា\", \"បិទ\", \"ៗ\", \"ប្រកាស\"],\n    [\"បិទ\", \"សញ្ញា\", \"អញ្ញ\"],\n    // Google has read it this way before, so being flexible\n    [\"បិទ\", \"សញ្ញា\", \"ៗ\"],\n    [\"សញ្ញា\", \"អញ្ញ\", \"បិទ\"],\n    // Google has read it this way before, so being flexible\n    [\"សញ្ញា\", \"ៗ\", \"បិទ\"],\n  ],\n};\n\nconst KHMER_PUNCTUATION_KEYS = Object.keys(KHMER_PUNCTUATION);\nconst ALL_KHMER_PUNCTUATION = Object.assign(\n  KHMER_PUNCTUATION,\n  KHMER_PUNCTUATION_NO_LEADER\n);\n\nconst khPunctuationLeader = \"សញ្ញា\";\n// hits anything with the khmer word for \"number\" before and then an Arabic numeral\nconst khNumber = \"លេខ\";\n// keep khmer writing on separate line if possible, or else vim gets messed up\n\n// if Google slams this together. Means \"one duck\" or \"two ducks\" but if in right context, we can\n// assume a Bible verse\nconst bonusOrdinals = [\"ទាមួយ\", \"ទាពីរ\"];\nconst khOrdinalIndicatorArr = [\n  \"ទី\",\n  // because sometimes Google sees this here instead\n  \"ទា\",\n  \"ទៀត\",\n].concat(bonusOrdinals);\nconst isNumber = (str) => str.match(/\\d/) || KHMER_NUMBERS.includes(str);\nconst ALL_BOOKS_NO_NUM = bookNames.ALL_BOOKS_NO_NUM;\n\nexport default {\n  // for different parts of a book, e.g., 1 Kings\n  khPart: \"ខ្សែ\",\n  khOrdinalIndicatorArr,\n  khOrdinalIndicatorRegEx: new RegExp(`${khOrdinalIndicatorArr.join(\"|\")}`),\n  khOrdinalRegEx: new RegExp(\n    `(${khOrdinalIndicatorArr.join(\"|\")})(\\d|${KHMER_NUMBERS.join(\"|\")})`\n  ),\n  khNumber,\n  khChapter: \"ជំពូក\",\n  // including some misspellings\n  khChapterRegex: new RegExp(\"ជំពូក|ចំពោះ|ជំពោះ\"),\n  khVerse: \"ខ\",\n  // including some misspellings\n  khVerseRegex: new RegExp(\"ខ|ខល\"),\n  referencesRegex: /\\s?ជំពូក\\s?(\\d+)\\s?ខ\\s?(\\d+)/gi,\n  // if colon before or after, counting it as reference, so handling differently\n  khmerNumberRegex: new RegExp(`(${khNumber})?\\\\s?(\\\\d)`, \"gi\"),\n  // global regexs don't capture\n  nonGlobalRegex: (reg) => new RegExp(reg.source, \"i\"),\n  // TODO I'm sure there's a more performant way to do this, but unless it's a math transcript we\n  // shouldn't call this too often anyways\n  isNumber,\n  convertToKhmerNumeral: (numStr) => {\n    const spelledOutIndex = KHMER_NUMBERS.indexOf(numStr);\n    let ret;\n    if (spelledOutIndex != -1) {\n      ret = KHMER_NUMERALS[spelledOutIndex];\n    } else {\n      ret = \"\";\n      // make sure if multidigit string, converts all\n      for (let i = 0; i < numStr.length; i++) {\n        ret += KHMER_NUMERALS[numStr[i]];\n      }\n    }\n\n    return ret;\n  },\n  punctuationRegex: new RegExp(\n    Object.keys(ALL_KHMER_PUNCTUATION).join(\"|\"),\n    \"gi\"\n  ),\n  // NOTE don't use when looking at individual words\n  preferredSpellingRegex: new RegExp(\n    Object.keys(PREFERRED_SPELLINGS).join(\"|\"),\n    \"gi\"\n  ),\n\n  khPunctuationLeader,\n  isEnglish: (wordData) => wordData.word.match(/^[a-zA-Z]+$/),\n\n  KHMER_PUNCTUATION,\n  KHMER_PUNCTUATION_NO_LEADER,\n  KHMER_PUNCTUATION_KEYS,\n  KHMER_PUNCTUATION_NO_LEADER_KEYS,\n  KHMER_NUMERALS,\n  KHMER_NUMBERS,\n  PREFERRED_SPELLINGS,\n  ZERO_WIDTH_SPACE: \"\\u200B\",\n  ALL_BOOKS_NO_NUM,\n  BOOKS_WITH_MANY_NO_NUM: bookNames.BOOKS_WITH_MANY_NO_NUM,\n  bonusOrdinals,\n  // check if set of two words returns an ordinal\n  isOrdinal: (word1, word2) =>\n    (khOrdinalIndicatorArr.includes(word1) &&\n      (KHMER_NUMBERS.includes(word2) || isNumber(word2))) ||\n    // hacky, but necessary to get edge cases\n    bonusOrdinals.includes(word1),\n\n  /*\n   * - takes a single word, which is from the utterance.alternatives[0].words array, and is tagged\n   * - since punctuation is dependent upon whether or not there is a following word and what it's\n   *   like, we need that info too\n   * @return boolean, whether or not there should be a real space (ie NOT zero-width space)\n   */\n\n  wordIsFollowedBySpace(wordData, nextWordData) {\n    const isFollowedBySpace =\n      nextWordData &&\n      ((!nextWordData.tags.includes(\"end-of-sentence\") &&\n        !nextWordData.tags.includes(\"closing-punctuation\") &&\n        wordData.tags.includes(\"followed-by-nbsp\")) ||\n        nextWordData.tags.includes(\"preceded-by-nbsp\"));\n\n    return isFollowedBySpace;\n  },\n\n  /*\n   * find sentences that are for punctuation, but are multiple words, e.g., for parenthesse and quotes.\n   */\n  multiwordPunctuationMatch: (allWords, currentIndex) => {\n    let keys = Object.keys(MULTI_WORD_KHMER_PUNCTUATION);\n    // iterate over each punctuation to see if there's a match\n    let ret = false;\n    // using some so stops when return true\n    keys.some((key) => {\n      // each punctuation might have multiple possible matches. Iterate over each one\n      let possibilitySet = MULTI_WORD_KHMER_PUNCTUATION[key];\n      // using some so stops when return true\n      // returning this, so stops enclosing some call also if this returns true\n      return possibilitySet.some((valArr) => {\n        // iterate over each word in the multi-word command to see if all match\n        // allWords[currentIndex] is the current word. i starts at 0, and sees if each word matches in\n        // succession\n        let match = valArr.every((wordToMatch, i) => {\n          return (\n            allWords[currentIndex + i] &&\n            wordToMatch == allWords[currentIndex + i].word\n          );\n        });\n        if (match) {\n          let wordData = allWords[currentIndex];\n          let matchedWordsData = _.range(valArr.length).map(\n            (i) => allWords[currentIndex + i]\n          );\n\n          ret = {\n            punctuation: key, // in this case, we're using the punctuation mark we want to return as key\n            multiwordLength: matchedWordsData.length,\n            originalWordData: { wordData },\n            averageConfidence:\n              matchedWordsData.reduce((acc, val) => acc + val.confidence, 0) /\n              matchedWordsData.length,\n            endTime: _.last(matchedWordsData).endTime,\n          };\n\n          // TODO for these use cases, rename key from secondWordData to \"wordData2\" so can easily\n          // set using originalWordData[`wordData${i}`]\n          if (valArr.length > 1) {\n            ret.originalWordData.secondWordData = matchedWordsData[1];\n          }\n          if (valArr.length > 2) {\n            ret.originalWordData.thirdWordData = matchedWordsData[2];\n          }\n          if (valArr.length > 3) {\n            ret.originalWordData.fourthWordData = matchedWordsData[3];\n          }\n          // shouldn't be more than 4, but to be safe\n          if (valArr.length > 4) {\n            ret.originalWordData.fourthWordData = matchedWordsData[4];\n          }\n\n          return true;\n        }\n      });\n    });\n\n    return ret;\n  },\n};\n","import Helpers from \"./khmer-helpers\";\n\n// extra tags to add for punctuations\nconst PUNCTUATION_EXTRA_TAGS = {\n    \"(\": [\"preceded-by-nbsp\", \"parentheses\", \"opening-punctuation\"],\n    // TODO test. Maybe google separates words differently for example\n    \")\": [\"followed-by-nbsp\", \"parentheses\", \"closing-punctuation\"],\n    \"៖\": [\"followed-by-nbsp\"],\n    \"«\": [\"preceded-by-nbsp\", \"quotation-marks\", \"opening-punctuation\"],\n    \"»\": [\"followed-by-nbsp\", \"quotation-marks\", \"closing-punctuation\"],\n    \"។\": [\"followed-by-nbsp\", \"end-of-sentence\"],\n    \"?\": [\"followed-by-nbsp\", \"end-of-sentence\"],\n    \"!\": [\"followed-by-nbsp\", \"end-of-sentence\"],\n  };\n  \nexport function combineKeywords(words) {\n  const ret = [];\n  for (let i = 0; i < words.length; i++) {\n    let wordData = words[i];\n    let secondWordData = words[i + 1] || {};\n    // set some defaults. Will change many of them\n    let word = wordData.word,\n      originalWordData = wordData,\n      confidence = wordData.confidence,\n      endTime = wordData.endTime,\n      startTime = wordData.startTime,\n      tags = [],\n      isDefault = true;\n\n    if (Helpers.ALL_BOOKS_NO_NUM.includes(wordData.word)) {\n      let thirdWordData = words[i + 2] || {};\n      let fourthWordData = words[i + 3] || {};\n      console.log(\"got a book!\", [\n        wordData.word,\n        secondWordData.word,\n        thirdWordData.word,\n        fourthWordData.word,\n      ]);\n      // is book of Bible, so watch out for funky handling by Google\n      // But not necessarily non-default\n\n      if (\n        Helpers.BOOKS_WITH_MANY_NO_NUM.includes(wordData.word) &&\n        Helpers.khPart == secondWordData.word &&\n        Helpers.isOrdinal(thirdWordData.word, fourthWordData.word)\n      ) {\n        isDefault = false;\n        // if 3rd is an ordinal by itself, it means Google sent the ordinal bunched together as\n        // one \"word\", so the fourth is not included\n        let allInOne = Helpers.bonusOrdinals.includes(thirdWordData.word);\n        if (allInOne) {\n          let num = thirdWordData.word.replace(\n            Helpers.khOrdinalIndicatorRegEx,\n            \"\"\n          );\n          word = `${Helpers.convertToKhmerNumeral(num)}${wordData.word}`;\n          confidence =\n            [wordData, secondWordData, thirdWordData].reduce(\n              (acc, val) => acc + val.confidence,\n              0\n            ) / 3;\n          originalWordData = { wordData, secondWordData, thirdWordData };\n          // leave the 4th one out of it\n          i += 2;\n        } else {\n          word = `${Helpers.convertToKhmerNumeral(fourthWordData.word)}${\n            wordData.word\n          }`;\n\n          // get the average and use as combined word confidence\n          // NOTE maybe we should be even more confident, since it fits this pattern?\n          confidence =\n            [wordData, secondWordData, thirdWordData, fourthWordData].reduce(\n              (acc, val) => acc + val.confidence,\n              0\n            ) / 4;\n          originalWordData = {\n            wordData,\n            secondWordData,\n            thirdWordData,\n            fourthWordData,\n          };\n          // skip next three words since we're combining them\n          i += 3;\n        }\n\n        tags.push(\"combined\");\n        tags.push(\"preceded-by-nbsp\");\n        tags.push(\"followed-by-nbsp\");\n        tags.push(\"book-name\");\n      }\n    } else if (wordData.word.match(Helpers.khChapterRegex)) {\n      // test if this is reference\n      // NOTE that we want to do this even if no book name is recognized, since often no book is\n      // recognized at all even if the end user said one\n      let thirdWordData = words[i + 2] || {};\n      let fourthWordData = words[i + 3] || {};\n\n      if (\n        Helpers.isNumber(secondWordData.word) &&\n        thirdWordData.word &&\n        thirdWordData.word.match(Helpers.khVerse) &&\n        Helpers.isNumber(fourthWordData.word)\n      ) {\n        // found a reference\n        isDefault = false;\n        word = `${Helpers.convertToKhmerNumeral(\n          secondWordData.word\n        )}:${Helpers.convertToKhmerNumeral(fourthWordData.word)}`;\n\n        // get the average and use as combined word confidence\n        // NOTE maybe we should be even more confident, since it fits this pattern?\n        confidence =\n          [wordData, secondWordData, thirdWordData, fourthWordData].reduce(\n            (acc, val) => acc + val.confidence,\n            0\n          ) / 4;\n        endTime = fourthWordData.endTime;\n        originalWordData = {\n          wordData,\n          secondWordData,\n          thirdWordData,\n          fourthWordData,\n        };\n        tags.push(\"combined\");\n        tags.push(\"preceded-by-nbsp\");\n        tags.push(\"followed-by-nbsp\");\n        tags.push(\"reference\");\n\n        // skip next three words since we're combining them\n        i += 3;\n      }\n    } else if (\n      wordData.word == Helpers.khPunctuationLeader &&\n      Helpers.KHMER_PUNCTUATION_KEYS.includes(secondWordData.word)\n    ) {\n      // don't just test all words and their following words, will slow things down\n\n      // this is punctuation\n      isDefault = false;\n      word = Helpers.KHMER_PUNCTUATION[secondWordData.word];\n      endTime = secondWordData.endTime;\n      originalWordData = { wordData, secondWordData };\n      confidence =\n        [wordData, secondWordData].reduce(\n          (acc, val) => acc + val.confidence,\n          0\n        ) / 2;\n      tags.push(\"combined\");\n      tags.push(\"punctuation\");\n\n      // skip next word since we're combining them\n      i += 1;\n    } else if (Helpers.KHMER_PUNCTUATION_KEYS.includes(wordData.word)) {\n      // this is for when GOogle just returns the punctuation sign on their own. We did not say the khPunctuationLeader, but they returned it.\n      // Mostly only happens with ។, I think\n      // this is punctuation\n\n      isDefault = false;\n      tags.push(\"punctuation\");\n      tags.push(\"google-returned-as-punctuation\");\n    } else if (\n      Helpers.KHMER_PUNCTUATION_NO_LEADER_KEYS.includes(wordData.word)\n    ) {\n      // is no leader punctuation. Not combining\n      isDefault = false;\n      // 6/23/21 I don't know if we've tried this one before yet, but I believe the following line of code is wrong, we're not combining, we're not even looking at the second word.\n      //word = Helpers.KHMER_PUNCTUATION_NO_LEADER[secondWordData.word]\n      tags.push(\"punctuation\");\n    } else if (\n      wordData.word == Helpers.khNumber &&\n      secondWordData &&\n      Helpers.isNumber(secondWordData.word)\n    ) {\n      // TODO Handle for edge cases. Most of the time, Google returns even multidigit numbers as a\n      // single \"word\". But this is worth testing more.\n\n      // recognizing this as numeral this whether the 2nd word is spelled out Khmer number or Arabic numeral\n      isDefault = false;\n\n      // if spelled out already, convert to numeral\n      word = Helpers.convertToKhmerNumeral(secondWordData.word);\n\n      endTime = secondWordData.endTime;\n      confidence =\n        [wordData, secondWordData].reduce(\n          (acc, val) => acc + val.confidence,\n          0\n        ) / 2;\n      originalWordData = { wordData, secondWordData };\n      tags.push(\"combined\");\n      tags.push(\"preceded-by-nbsp\");\n      tags.push(\"followed-by-nbsp\");\n      tags.push(\"numeral\");\n\n      // skip next word since we're combining them\n      i += 1;\n    } else if (Helpers.KHMER_NUMBERS.includes(wordData.word)) {\n      // sometimes they spell it for us. In which case, just add the right tag\n      isDefault = false;\n      tags.push(\"spelled-out-number\");\n    } else if (wordData.word.match(/\\d/)) {\n      isDefault = false;\n      // means the previous word was not the Khmer word for number, since we already ruled this\n      // out, so hopefully speaker wants it\n      // spelled out\n\n      // sometimes there are non-number parts included on the same word...shame on you Google!\n      // For example, 2020_05_04_19_31_55.flac\n      // But need to keep that part separate\n      // find only the number, in case they mixed letters in the same word\n      let numberMatch = wordData.word.match(/^[^\\d]*(\\d+)[^\\d]*$/);\n      // make sure numberMatch is not null\n      // TODO test this more to make sure there aren't cases to make sure we cover here\n      let number = numberMatch ? numberMatch[1] : wordData.word.match(/\\d/);\n\n      if (wordData.word.length > 1) {\n        // just use numeral anyways\n        word = Helpers.convertToKhmerNumeral(number);\n        tags.push(\"numeral\");\n        tags.push(\"preceded-by-nbsp\");\n        tags.push(\"followed-by-nbsp\");\n      } else {\n        // spell it out\n        word = Helpers.KHMER_NUMBERS[number];\n        tags.push(\"spelled-out-number\");\n      }\n\n      // add the rest back in\n      let nonNumbers = wordData.word.match(new RegExp(`^(.*)?${number}(.*)?$`));\n      if (nonNumbers[1] || nonNumbers[2]) {\n        tags.push(\"letters-and-numbers-in-one\");\n\n        if (nonNumbers[1]) {\n          word = nonNumbers[1] + word;\n        }\n        if (nonNumbers[2]) {\n          word = word + nonNumbers[2];\n        }\n      }\n    } else if (Helpers.multiwordPunctuationMatch(words, i)) {\n      // checks if matches punctuations where their commands are more than one word\n      // it's a little slower to have to call twice, but only runs twice if there's a match, which\n      // shouldn't be that often, and it makes for relatively clean code.\n      // Could probably improve this too though\n      isDefault = false;\n      let match = Helpers.multiwordPunctuationMatch(words, i);\n      word = match.punctuation;\n\n      tags.push(\"multiword-punctuation\");\n      tags.push(\"punctuation\");\n\n      endTime = match.endTime;\n      confidence = match.averageConfidence;\n      originalWordData = match.originalWordData;\n\n      i += match.multiwordLength;\n    } else if (Helpers.PREFERRED_SPELLINGS[wordData.word]) {\n      // NOTE this should always be second to last check. Otherwise we want to change the word to a punctuation/number\n      isDefault = false;\n      let preferredSpelling = Helpers.PREFERRED_SPELLINGS[wordData.word];\n      console.log(\"found alt spelling\", wordData, preferredSpelling);\n      word = preferredSpelling;\n      tags.push(\"corrected-spelling\");\n    } else if (Helpers.isEnglish(wordData)) {\n      // NOTE this should always be last check. Otherwise we want to change the word to a punctuation/number\n      // English words should have spaces.\n      // Other than that can be default\n      tags.push(\"English\");\n      tags.push(\"preceded-by-nbsp\");\n      tags.push(\"followed-by-nbsp\");\n    }\n\n    if (isDefault) {\n      // word is ready to be used as is\n      tags.push(\"default\");\n    }\n\n    if (tags.includes(\"punctuation\")) {\n      if (PUNCTUATION_EXTRA_TAGS[word]) {\n        tags = tags.concat(PUNCTUATION_EXTRA_TAGS[word]);\n      }\n    }\n\n    let processedWordData = {\n      originalWordData,\n      word,\n      confidence,\n      endTime,\n      startTime,\n      tags,\n      // keep prev and next word unprocessed...or else we get into trouble with combined phrases\n      //prevWordData: i > 0 ? words[i-1] : null,\n      //nextWordData,\n    };\n    ret.push(processedWordData);\n  }\n\n  return ret;\n}\n","import React, { Component } from \"react\";\n// import getAudio from './getAudio'\nimport SpeechRecognition from \"../updated-react-speech-recognition/src/\";\nimport {\n  secondsToTimecode,\n  timecodeToSeconds,\n} from \"../Util/timecode-converter/index\";\nimport \"./style.css\";\n\nimport { Editor, EditorState, SelectionState, Modifier, ContentState } from \"draft-js\";\nimport { combineKeywords } from \"./helpers/combine-keywords\";\nimport { split } from \"split-khmer\";\nimport Helpers from \"./helpers/khmer-helpers\";\n\n/*\nconst propTypes = {\n  // Props injected by SpeechRecognition\n  transcript: PropTypes.string,\n  resetTranscript: PropTypes.func,\n  browserSupportsSpeechRecognition: PropTypes.bool\n}\n*/\n\nconst manualFixes = [\n  {\n    modified: \"សេចក**ី\",\n    target: \"សេចក្ដី\",\n  },\n  {\n    modified: \"ក**ៅ\",\n    target: \"ក្ដៅ\",\n  },\n];\n\nconst languages = [\n  [\"AF\", \"Afrikaans\"],\n  [\"SQ\", \"Albanian\"], \n  [\"AR\", \"Arabic\"], \n  [\"HY\", \"Armenian\"], \n  [\"EU\", \"Basque\"], \n  [\"BN\", \"Bengali\"], \n  [\"BG\", \"Bulgarian\"], \n  [\"CA\", \"Catalan\"], \n  [\"ZH\", \"Chinese (Mandarin)\"], \n  [\"HR\", \"Croatian\"], \n  [\"CS\", \"Czech\"], \n  [\"DA\", \"Danish\"], \n  [\"NL\", \"Dutch\"], \n  [\"EN\", \"English\"], \n  [\"ET\", \"Estonian\"], \n  [\"FJ\", \"Fiji\"], \n  [\"FI\", \"Finnish\"], \n  [\"FR\", \"French\"], \n  [\"KA\", \"Georgian\"], \n  [\"DE\", \"German\"], \n  [\"EL\", \"Greek\"], \n  [\"GU\", \"Gujarati\"], \n  [\"HE\", \"Hebrew\"], \n  [\"HI\", \"Hindi\"], \n  [\"HU\", \"Hungarian\"], \n  [\"IS\", \"Icelandic\"], \n  [\"ID\", \"Indonesian\"], \n  [\"GA\", \"Irish\"], \n  [\"IT\", \"Italian\"], \n  [\"JA\", \"Japanese\"], \n  [\"JW\", \"Javanese\"], \n  [\"KM\", \"Khmer\"], \n  [\"KO\", \"Korean\"], \n  [\"LA\", \"Latin\"], \n  [\"LV\", \"Latvian\"], \n  [\"LT\", \"Lithuanian\"], \n  [\"MK\", \"Macedonian\"], \n  [\"MS\", \"Malay\"], \n  [\"ML\", \"Malayalam\"], \n  [\"MT\", \"Maltese\"], \n  [\"MI\", \"Maori\"], \n  [\"MR\", \"Marathi\"], \n  [\"MN\", \"Mongolian\"], \n  [\"NE\", \"Nepali\"], \n  [\"NO\", \"Norwegian\"], \n  [\"FA\", \"Persian\"], \n  [\"PL\", \"Polish\"], \n  [\"PT\", \"Portuguese\"], \n  [\"PA\", \"Punjabi\"], \n  [\"QU\", \"Quechua\"], \n  [\"RO\", \"Romanian\"], \n  [\"RU\", \"Russian\"], \n  [\"SM\", \"Samoan\"], \n  [\"SR\", \"Serbian\"], \n  [\"SK\", \"Slovak\"], \n  [\"SL\", \"Slovenian\"], \n  [\"ES\", \"Spanish\"], \n  [\"SW\", \"Swahili\"], \n  [\"SV\", \"Swedish \"], \n  [\"TA\", \"Tamil\"], \n  [\"TT\", \"Tatar\"], \n  [\"TE\", \"Telugu\"], \n  [\"TH\", \"Thai\"], \n  [\"BO\", \"Tibetan\"], \n  [\"TO\", \"Tonga\"], \n  [\"TR\", \"Turkish\"], \n  [\"UK\", \"Ukrainian\"], \n  [\"UR\", \"Urdu\"], \n  [\"UZ\", \"Uzbek\"], \n  [\"VI\", \"Vietnamese\"], \n  [\"CY\", \"Welsh\"], \n  [\"XH\", \"Xhosa\"], \n]\n  \nconst tmpLocalStorageKey = \"khmer-replacer-json-LATEST\"\n\nclass GenerateTranscript extends Component {\n  constructor(props) {\n    super(props);\n    const editorState = EditorState.createEmpty();\n    this.state = {\n      error: \"\",\n      words: [],\n      editorState: EditorState.moveFocusToEnd(editorState),\n      oldWords: [],\n      oldEditorState: null,\n      // the parsed json obj to use in replacing\n      replacer: {},\n      // the string that sits in the field\n      replacerTextareaValue: \"\",\n      shouldAddSpace: false,\n    };\n\n    this.onChange = (editorState) => this.setState({ editorState });\n    this.pause = this.pause.bind(this);\n    this.start = this.start.bind(this);\n    this.reset = this.reset.bind(this);\n    this.copy = this.copy.bind(this);\n    this.undo = this.undo.bind(this);\n    this.resplit = this.resplit.bind(this);\n    this.changeReplacerHook = this.changeReplacerHook.bind(this);\n    this.setReplacerLocalStorage = this.setReplacerLocalStorage.bind(this);\n    this.getReplacerFromLocalStorage = this.getReplacerFromLocalStorage.bind(this);\n\n\n    // props.recognition.onresult\n    // set default language to Khmer TODO add options?\n    // https://www.science.co.il/language/Locale-codes.php for codes\n    props.recognition.lang = \"KM\";\n  }\n\n  componentDidMount () {\n    // pull from temp storage\n    console.log(\"on mount hook\")\n    this.getReplacerFromLocalStorage(null, \"LATEST\")\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    if (\n      props.transcriptData &&\n      props.transcriptData.words.length > state.words.length\n    ) {\n      const sentence =\n        props.transcriptData.words[props.transcriptData.words.length - 1];\n\n      try {\n        let phrase = sentence.word;\n        let textToAdd = \"\";\n        if (props.recognition.lang === \"KM\") {\n          manualFixes.forEach((modifier) => {\n            phrase = phrase.replace(modifier.modified, modifier.target);\n          });\n\n          const splitWords = combineKeywords(\n            split(phrase).map((word) => {\n              return {\n                ...sentence,\n                word: Helpers.PREFERRED_SPELLINGS[word] || state.replacer[word] || word,\n              };\n            })\n          );\n          textToAdd = splitWords\n            .map((word) => word.word)\n            .join(Helpers.ZERO_WIDTH_SPACE);\n        } else {\n          textToAdd = phrase\n            .split(\" \")\n            .map((word) => state.replacer[word] || word)\n            .join(\" \");\n        }\n        textToAdd += state.shouldAddSpace ? \" \" : \"\";\n        const currentContent = state.editorState.getCurrentContent();\n\n        // create new selection state where focus is at the end\n        const selection = state.editorState.getSelection();\n        //insert text at the selection created above\n        const textWithInsert = Modifier.insertText(\n          currentContent,\n          selection,\n          textToAdd,\n          null\n        );\n        const newEditorState = EditorState.push(\n          state.editorState,\n          textWithInsert,\n          \"insert-characters\"\n        );\n\n        return {\n          ...state,\n          editorState: newEditorState,\n          words: [...props.transcriptData.words],\n        };\n      } catch (e) {\n        console.error(e);\n        return {\n          ...state,\n          error: \"Could not add \" + sentence.word,\n        };\n      }\n    }\n\n    return null;\n  }\n\n\n  reset(e) {\n    e.preventDefault()\n\n    this.props.stopListening();\n    this.props.resetTranscript();\n    const editorState = EditorState.createEmpty();\n    this.setState({\n      error: \"\",\n      editorState: EditorState.moveFocusToEnd(editorState),\n      words: [],\n      oldEditorState: this.state.editorState,\n      oldWords: this.state.words,\n    });\n  }\n\n  start(e) {\n    e.preventDefault()\n    this.props.startListening();\n  }\n\n  pause(e) {\n    e.preventDefault()\n    this.props.stopListening();\n  }\n\n  copy(e) {\n    e.preventDefault()\n    const text = this.state.editorState.getCurrentContent().getPlainText();\n    var input = document.createElement(\"input\");\n    input.setAttribute(\"value\", text);\n    document.body.appendChild(input);\n    input.select();\n    var result = document.execCommand(\"copy\");\n    document.body.removeChild(input);\n    return result;\n  }\n  undo(e) {\n    this.setState({\n      ...this.state,\n      oldEditorState: null,\n      oldWords: null,\n      editorState: this.state.oldEditorState,\n      words: this.state.oldWords,\n    });\n  }\n\n  /**\n   *\n   * pass in \"LATEST\" in order to get last auto-saved text\n   */ \n  getReplacerFromLocalStorage(e, index) {\n    e && e.preventDefault()\n\n    const localStorageKey = `khmer-replacer-json-${index}`\n    console.log(\"retrieving from: \", localStorageKey)\n    const retrievedReplacer = localStorage.getItem(localStorageKey)\n    console.log(\"retrieved: \",retrievedReplacer)\n\n    this.changeReplacerHook(null, retrievedReplacer)\n  }\n\n  setReplacerLocalStorage(e, index) {\n    e && e.preventDefault()\n\n    try { \n      const newReplacer = this.state.replacerTextareaValue\n      console.log(\"saving to local storage: \",newReplacer)\n      localStorage.setItem(`khmer-replacer-json-${index}`, newReplacer)\n\n    } catch(err){\n      console.error(err)\n    }\n  }\n\n  changeReplacerHook(e, value) {\n    e && e.preventDefault()\n    const replacerValue = value || e && e.target.value\n    // NOTE make sure this is a string as we pass it in\n    console.log(\"set tmp local storage!\")\n    localStorage.setItem(tmpLocalStorageKey, replacerValue)\n    this.setState({replacerTextareaValue: replacerValue || \"\"});\n\n    try { \n\n      const newReplacer = JSON.parse(replacerValue);\n      this.setState({replacer: newReplacer});\n      console.log(\"set to\", newReplacer)\n\n    } catch(err){\n      console.error(err)\n      console.log(\"temporarily using no replacer at all...(but not changing the text in the editor\")\n      this.setState({replacer: {}});\n    }\n  }\n\n  resplit(e) {\n    var text = this.state.editorState.getCurrentContent().getPlainText();\n    text = text.replace(Helpers.ZERO_WIDTH_SPACE, '');\n    const splitWords = split(text);\n    var textToAdd = splitWords.join(Helpers.ZERO_WIDTH_SPACE);\n    const newEditorState = EditorState.createWithContent(ContentState.createFromText(textToAdd));\n    this.setState({\n        editorState: newEditorState,\n        oldEditorState: this.state.editorState,\n    });\n  }\n\n  render() {\n    const {\n      transcript,\n      browserSupportsSpeechRecognition,\n      // interimTranscript,\n      listening,\n      // allResults\n    } = this.props;\n\n    if (!browserSupportsSpeechRecognition) {\n      // NOTE happens several times, as this gets rerendered for some reason. Returns false even when browser can support sometimes for some reason too, but eventually returns true\n      return null;\n    }\n    //TODO add back in once we switch over to using my fork  which passes down all results as an array rather than compiling all into a string\n\n    return (\n      <div>\n        <h1>Speech Recognition v2.0.9</h1>\n        <select\n          onChange={(e) => {\n            this.props.recognition.lang = e.target.value;\n          }}\n          defaultValue={this.props.recognition.lang}\n          data-placeholder=\"Choose a Language...\"\n        >\n          {languages.map(lang => (\n            <option value={lang[0]}>{lang[1]}</option>\n          ))}\n        </select>\n        <button\n          disabled={!this.state.oldEditorState}\n          onClick={this.undo}\n        >\n          Undo\n        </button>\n        <button onClick={this.reset}>\n          Reset\n        </button>\n        <button onClick={this.start}>\n          Start\n        </button>\n        <button onClick={this.pause}>\n          Pause\n        </button>\n        <button onClick={this.copy}>\n          Copy\n        </button>\n        <button onClick={this.resplit}>\n          Resplit\n        </button>\n\n        <label>\n          Should add space?:\n          <input\n            name=\"shouldAddSpace\"\n            type=\"checkbox\"\n            checked={this.state.shouldAddSpace}\n            onChange={(e) => {\n              this.setState({ shouldAddSpace: !this.state.shouldAddSpace });\n            }}\n          />\n        </label>\n\n        {/* <button disabled={!this.props.finalTranscript || this.props.finalTranscript !== this.props.transcript} onClick={this.stop} onMouseDown={e => e.preventDefault()}>Insert</button> */}\n        <br />\n        <div className=\"transcript-container\">\n          In progress:{\" \"}\n          {this.props.finalTranscript !== this.props.transcript\n            ? this.props.interimTranscript\n            : \"\"}{\" \"}\n          ...\n          <br />\n          {this.state.error && (\n            <span style={{ color: \"red\" }}>{this.state.error}</span>\n          )}\n        </div>\n        {listening ? (\n          <span>\n            *Listening* Total Time Elapsed:{\" \"}\n            {secondsToTimecode(this.props.totalTimeElapsed)}\n          </span>\n        ) : (\n          <div>&nbsp;</div>\n        )}\n        <Editor editorState={this.state.editorState} onChange={this.onChange} />\n\n        <br />\n        <div>\n          <label>Replacer: </label>\n          <textarea \n            style={{width: \"400px\"}} \n            placeholder='Ex. {\"target\": \"modifier\", \"target2\": \"modifier2\"}' \n            onChange={this.changeReplacerHook} \n            value={this.state.replacerTextareaValue}\n          />\n        </div>\n\n        <div>\n          {[1,2].map(index => (\n            <div>\n              <button onClick={(e) => this.setReplacerLocalStorage(e, index)}>\n                Save to options #{index}\n              </button>\n              <button onClick={(e) => this.getReplacerFromLocalStorage(e, index)}>\n                Retrieve from options #{index}\n              </button>\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  }\n}\n\n// GenerateTranscript.propTypes = propTypes\n\nconst options = {\n  autoStart: false,\n};\nexport default SpeechRecognition(options)(GenerateTranscript);\n","import React from \"react\";\nimport { render } from \"react-dom\";\n\nimport { TranscriptEditor, GenerateTranscript } from \"./lib\";\n\nimport kaldiTedTalkTranscript from \"./sample-data/KateDarling_2018S-bbc-kaldi.json\";\nimport khmerRougeTranscript from \"./sample-data/khmer-rouge-interview-data.json\";\nimport style from \"./index.module.css\";\nimport SttTypeSelect from \"./select-stt-json-type\";\nimport ExportFormatSelect from \"./select-export-format\";\n\n// import khmerRougeInterviewTranscript from './sample-data/khmer-rouge-interview-transcript-data.json';\n\nconst tedTalkVideoUrl =\n  \"https://download.ted.com/talks/KateDarling_2018S-950k.mp4\";\nconst khmerRougeInterviewTranscript =\n  \"https://av.voanews.com/Videoroot/Pangeavideo/2019/01/b/b8/b83b37e5-3deb-4668-9daa-b2837648799f.mp4?download=1\"; // 360px (270, 720, and 1080 available)\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      transcriptData: null,\n      mediaUrl: null,\n      isTextEditable: true,\n      sttType: \"bbckaldi\",\n      analyticsEvents: [],\n      fileName: \"Khmer Transcript Data\",\n      playingWhileListening: false,\n    };\n\n    this.transcriptEditorRef = React.createRef();\n    this.startListeningAndPlayingMedia = this.startListeningAndPlayingMedia.bind(\n      this\n    );\n  }\n\n  loadDemo() {\n    this.setState({\n      transcriptData: khmerRougeTranscript,\n      mediaUrl: khmerRougeInterviewTranscript,\n      sttType: \"bbckaldi\",\n      fileName: \"transcript-data\",\n    });\n  }\n\n  startListeningAndPlayingMedia(e) {\n    this.setState({ playingWhileListening: true });\n  }\n\n  // https://stackoverflow.com/questions/8885701/play-local-hard-drive-video-file-with-html5-video-tag\n  handleChangeLoadMedia(files) {\n    console.log(files);\n    const file = files[0];\n    const type = file.type;\n    // check if is playable\n    const videoNode = document.createElement(\"video\");\n    const canPlay = videoNode.canPlayType(type);\n    if (canPlay) {\n      const fileURL = URL.createObjectURL(file);\n      // videoNode.src = fileURL\n      this.setState({\n        // transcriptData: kaldiTedTalkTranscript,\n        mediaUrl: fileURL,\n        fileName: file.name,\n      });\n    } else {\n      alert(\"select a valid audio or video file\");\n    }\n  }\n\n  handleChangeLoadMediaUrl() {\n    const fileURL = prompt(\"Paste the URL you'd like to use here\");\n\n    this.setState({\n      // transcriptData: kaldiTedTalkTranscript,\n      mediaUrl: fileURL,\n    });\n  }\n\n  handleChangeLoadTranscriptJson(files) {\n    const file = files[0];\n\n    if (file.type === \"application/json\") {\n      const fr = new FileReader();\n\n      fr.onload = (evt) => {\n        this.setState({\n          transcriptData: JSON.parse(evt.target.result),\n        });\n      };\n\n      fr.readAsText(file);\n    } else {\n      alert(\"select a valid json file\");\n    }\n  }\n\n  handleIsTextEditable = () => {\n    this.setState((prevState) => ({\n      isTextEditable: prevState.isTextEditable !== true,\n    }));\n  };\n\n  // https://stackoverflow.com/questions/21733847/react-jsx-selecting-selected-on-selected-select-option\n  handleSttTypeChange = (event) => {\n    console.log(event.target.name, event.target.value);\n    this.setState({ [event.target.name]: event.target.value });\n  };\n\n  handleExportFormatChange = (event) => {\n    console.log(event.target.name, event.target.value);\n    this.setState({ [event.target.name]: event.target.value });\n  };\n\n  exportTranscript = () => {\n    // eslint-disable-next-line react/no-string-refs\n    const { data, ext } = this.transcriptEditorRef.current.getEditorContent(\n      this.state.exportFormat\n    );\n    this.download(data, `${this.state.mediaUrl}.${ext}`);\n  };\n\n  // https://stackoverflow.com/questions/2897619/using-html5-javascript-to-generate-and-save-a-file\n  download = (content, filename, contentType) => {\n    const type = contentType || \"application/octet-stream\";\n    const a = document.createElement(\"a\");\n    const blob = new Blob([content], { type: type });\n\n    a.href = window.URL.createObjectURL(blob);\n    a.download = filename;\n    a.click();\n  };\n\n  clearLocalStorage = () => {\n    localStorage.clear();\n    console.info(\"cleared local storage\");\n  };\n\n  handleAnalyticsEvents = (event) => {\n    this.setState({ analyticsEvents: [...this.state.analyticsEvents, event] });\n  };\n\n  handleChangeTranscriptName = (value) => {\n    this.setState({ fileName: value });\n  };\n\n  playMedia;\n  render() {\n    return (\n      <div className={style.container}>\n        <span className={style.title}>\n          Demo page for <mark>Khmer Transcript Creator</mark> - Component\n          |&nbsp;\n          <a\n            href=\"https://github.com/RyanQuey/khmer-react-transcript-creator\"\n            rel=\"noopener noreferrer\"\n            target=\"_blank\"\n          >\n            Github Repo\n          </a>\n        </span>\n        <GenerateTranscript />\n      </div>\n    );\n  }\n}\n\nrender(<App />, document.getElementById(\"root\"));\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"src_container__uc_5O\"};"],"sourceRoot":""}